<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSP-S2019爆零游记</title>
    <url>/CSP-S2019%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="CSP-S2019爆零游记"><a href="#CSP-S2019爆零游记" class="headerlink" title="CSP-S2019爆零游记"></a>CSP-S2019爆零游记</h1><p>首先，恭喜第一届全国中学生树学竞赛圆满结束[滑稽]</p><a id="more"></a><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h2><p>咕掉了周四的晚自习和作业，下午放学回到家吃完饭开始敲生成树和最短路的板子</p><p>但是一晚上心思都在调博客，只敲了$kruskal$和$dijkstra$</p><p>于是又成功的熬到了23点才去睡觉</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>又是老早就醒了（甚至比上学醒得都早）</p><p>果然还是又赖到6点才起来</p><p>吃完早饭发现自己成功错过$25\ min$一班的公交车</p><p><del>二中高中部什么偏僻地方，公交车还走城乡结合部绕来绕去</del></p><p>公交车上尝试做道生成树的题 <em><a href="https://www.luogu.org/problem/P1967" target="_blank" rel="noopener">P1967 货车运输</a></em></p><p>看了看大概是先搞最大生成树再LCA求距离</p><p>于是从上午的火车上一直调到晚上吃饭也没调好（心态爆炸）</p><p>晚上试机的时候尝试敲线段树发现只会建树 直接自闭</p><p>回来之后到对门的黑网吧去敲板子</p><p>至少8台电脑让对门温度高了至少$5^\circ C$</p><p>敲了个线性筛素数后复习线段树一</p><p>直到熄灯也没调出来</p><p>不过睡觉的时候自我安慰<del>至少如果考生成树和LCA我应该不会挂吧</del></p><p>事实上整个CSP都与图和数据结构无瓜（</p><h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h3><p>吃完饭回到宿舍原本还想再看看的</p><p>结果直接被神sir一句</p><blockquote><p>“门我给你们锁上，你们放心地去吧”</p></blockquote><p>劝退去考场</p><p>路上看了看线段树和最短路</p><p>发密码时候密码”认真思考”？</p><p>好像挺有道理</p><h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h4><p>第一眼一看像个搜索</p><p>结果DFS一调就是$2\ hours$</p><p>心态直接爆炸</p><p>用<code>vector</code>写了个模拟直接自闭</p><p>后来回宿舍咕咕自测<script type="math/tex">MLE</script>了$50\%$</p><p>被同宿舍$AC$了的翟神和一堆只扣5分的<code>dalao</code>们好一个嘲讽</p><p>$\color{orange}{橙题}$都做不出来我蒻死了</p><h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h4><p>写了个暴力</p><p>结果发现不会判断合法括号序列</p><p>比如<code>(())</code>判断成不合法（zb</p><p>回家想了一下发现自己应该会写暴力</p><p>可能还有一点优化</p><p>不过考场上写不出来真的是让人自闭（跟去年pjT2一样</p><h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br></pre></td></tr></table></figure><p>走人</p><p>样例一股恶臭（ <code>n = 114514</code>?）</p><p>PS: 当晚发现一橙一蓝一紫</p><h3 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h3><p>当平衡心态把上午的题投到我校OJ上去</p><p><del>顺道发现一个bug?</del></p><p>之后下午整个宿舍在$Undertale$、$Arcaea$、$Minecraft$和其它音游中度过</p><p>还有对门的<code>奥力给</code>和LWLA的女装（真的可爱</p><p>尝试MC联机结果连不上去让我更加自闭</p><p>17点的时候开始敲<code>SegmentFault</code></p><p>没一会就被叫去吃饭了</p><p>晚上回来后终于把线段树一调出来了</p><p>可是二还是炸 zb</p><p>晚上pj的题出来了</p><p>被同宿舍的神仙全切了</p><p>在wmy大佬出去串门的时候</p><p>我把我U盘插到他电脑上</p><p>双击<code>----------------- - X.J.P.osz</code>（素质</p><p>睡觉前还要填什么社保的单子</p><p>直到睡觉前才搞完传到咕咕剪切板上发给班长</p><p>22:34，班长来了句</p><blockquote><p>“网址打不开”</p></blockquote><p>结果已经关灯 Day2六点才发现</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><h3 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h3><p>吃饭时候感觉肚子不舒服</p><p>回宿舍发现我吃饭吃的最慢</p><p>进考场之前现借纸去了趟WC</p><p>今日密码”抓紧时间”</p><p>考完后发现是个真理</p><h4 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h4><p>什么饭呀那么香</p><p>感觉又是大法师</p><p>$1.5\ hour$过去了直接自闭</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rand() % <span class="number">10</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>再见</p><h4 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h4><p><code>type = 0</code>时</p><p>写了个蜜汁前缀和+蜜汁判断条件</p><p>居然过了两个小样例</p><p>不过大样例依然炸掉</p><p><code>type = 1</code>时</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (type) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"NOIP is dead!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>素质真的是比华莱士都高</p><h4 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h4><p>看到时T3只剩半个小时了</p><p>把链的情况写出来</p><p>看到样例才发现不是从$1$到$n$的链</p><p>这个时候离考试结束还有5分钟</p><p>自闭辽</p><p>下午看到难度时紫黑紫</p><p>更加自闭（话说我尝试做黑题来着？）</p><p>回家路上听一群强者唱大葱进行曲|膜葱一代|放高利贷</p><p>Emiya天天吃划分好重心的树就好啦awa</p><p><strong>留下了省四的泪水</strong></p><p>其实还好吧</p><p>现在除了砍树啥也不想干</p><p>不考数据结构不考图论不考睡论（考了我也不会</p><p>考了三棵树zb</p><hr><p>说实话</p><p>考完试第二天一整天都有点抑郁</p><p>看着那么多前辈AFO</p><p>从今年初赛第一次见到真容的yt</p><p>到十一前几个周才认识的wqx</p><p>还有十一qbxt上手撕难题的rk1糯米教主</p><p>再加上zqm</p><p>还有高二的一群dalao</p><p>还可能会有高一的OIer</p><blockquote><p>开始了</p><p>结束了</p><p>从Hellow到Goodbye</p><p>也不是很容易吧 (By wqx)</p></blockquote><hr><p>一些梗：</p><blockquote><p>花了$\frac{1}{5}$的钱打了场NOI</p><p>NOIP的价格，NOI的质量</p><p>OIer从不在一棵树上吊死</p><p>​ ——我们要吊死就是三棵树一起 (By LWLAymh)</p><p>少年不识愁滋味<br>——为做树学强说愁 (By LWLAymh)</p><p>出题人A：五黑吗？</p><p>​ ——出题人BCDEF：好 (By Corycle)</p><p>起床数树！ (By kenlig)</p><p>树学能力认证 (By MikuNotFoundException)</p><p>CCF门前有六棵树<br>其中三棵挂满了Oiers<br>另三棵也挂满了Oiers (By 夏天不听话)</p><p>CCF一到店，所有写题的人便都看着他笑，有的叫道，“CCF，你NOIP又换成新CSP了！”他不回答，对机房里说，“温两颗树，要一个二进制串。”便排出三道大题。他们又故意的高声嚷道，“你一定又说CSP和NOIP没有任何关系了！”CCF睁大眼睛说，“你怎么这样凭空污人清白……”“什么清白？我前天亲眼见你出了道黑题，把我们吊着打。”CCF便涨红了脸，额上的青筋条条绽出，争辩道，“黑题不能算黑……黑题！……提高组的事，能算黑么？”接连便是难懂的话，什么“NOIP死了”，什么“CSP-S”之类，引得众人都哄笑起来：机房内外充满了快活的空气。 (By Y15BeTa)</p><p><a href="https://www.zhihu.com/question/356271858/answer/897861789" target="_blank" rel="noopener">CSP*美人鱼</a></p><p><img data-src="/images/ceshuxue.jpg" alt=""></p><p><img data-src="/images/liangkeshu.jpg" alt=""></p></blockquote>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>P5665划分</title>
    <url>/P5665%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>在CSP结束近一年后，终于听人讲了这道题</p><a id="more"></a><p><del>惭愧啊 惭愧</del></p><h3 id="36pts"><a href="#36pts" class="headerlink" title="36pts"></a>36pts</h3><h5 id="一个考场都没想出来的-n-3-暴力DP"><a href="#一个考场都没想出来的-n-3-暴力DP" class="headerlink" title="一个考场都没想出来的$n^3$暴力DP"></a>一个考场都没想出来的$n^3$暴力DP</h5><p>设$f_{i,j}$为考虑到$i$这个点，$i$所在块的起点为$j$，最小的时间代价</p><p>更新方法就是把$k$从$1$到$j-1$枚举，当满足题目条件($\sum\limits_{l=k}^{j-1}{a_l}\leq\sum\limits_{l=j}^{i}{a_l}$)时，$f_{i,j}=\min\{ {f_{j-1,k}+(\sum\limits_{l=j}^{i}{a_l})^2}\}$</p><p>统计答案时，$ans=\min_{i=1}^{n}{ \{f_{n,i}\} }$</p><p>记得开<code>long long</code></p><h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f),</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//枚举运算到的位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123; <span class="comment">//枚举断点</span></span><br><span class="line">		<span class="keyword">if</span> (!j || j == <span class="number">1</span>)</span><br><span class="line">			f[i][j] = sum[i] * sum[i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= j - <span class="number">1</span>; ++k) <span class="comment">//枚举比j更早的断点</span></span><br><span class="line">			<span class="keyword">if</span> (sum[j - <span class="number">1</span>] - sum[k - <span class="number">1</span>] &lt;= sum[i] - sum[j - <span class="number">1</span>])</span><br><span class="line">				f[i][j] = min(f[i][j], f[j - <span class="number">1</span>][k] + (sum[i] - sum[j - <span class="number">1</span>]) * (sum[i] - sum[j - <span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		ans = min(ans, f[n][i]);</span><br></pre></td></tr></table></figure><h3 id="64pts"><a href="#64pts" class="headerlink" title="64pts"></a>64pts</h3><p>首先由完全平方公式可以推出，$(\sum\limits_{i=1}^{n}a_i)^2\geq\sum\limits_{i=1}^{n}a_i^2$，当且仅当$a_i=0$时等号成立</p><p>所以如果想让总代价更小，要<strong>尽量多分块</strong></p><p>用$f_i$表示将$1$到$i$按最优方案划分后的时间代价，$g_i$表示将$1$到$i$按最优方案划分后，最后一段的的开头为$k$，有式子</p><script type="math/tex;mode=display">g_i=\sum\limits_{l=k}^{i}{a_l}</script><p>同时，显然已经划分过的段不会再参与到之后的划分中，所以令$top$表示上一次划分到的块的终点，下次划分时从$top$开始枚举即可</p><p>每次$j$从$top + 1$枚举到$i-1$，判断满足$\sum\limits_{j=top+1}^{i-1}{a_j}\geq g_j$，更新$f_i$，$g_i$和$top$即可</p><p>答案$ans=f_n$</p><h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">//枚举运算到的位置</span></span><br><span class="line">	f[i] = <span class="number">99999999999999999</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = top; j &lt; i; ++j) &#123; <span class="comment">//枚举断点</span></span><br><span class="line">		<span class="keyword">if</span> (sum[i] - sum[j] &gt;= g[j])</span><br><span class="line">			f[i] = min(f[i], f[j] + (sum[i] - sum[j]) * (sum[i] - sum[j])),</span><br><span class="line">			g[i] = sum[i] - sum[j],</span><br><span class="line">			top = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的题解是用$g_i$表示满足条件的最大的$j$，即$g_i=\max\limits_{\sum\limits_{l=g_j}^{j}{a_l}\leq\sum\limits_{l=j+1}^{i}{a_l} }{ \{j\} }$</p><h3 id="88pts"><a href="#88pts" class="headerlink" title="88pts"></a>88pts</h3><p>对于判断合法的式子$\sum\limits_{l=g_j+1}^{j}{a_l}\leq\sum\limits_{l=j+1}^{i}{a_l}$，将其用前缀和表示出来，即为$sum_{j}-sum_{g_j}\leq sum_i-sum_j$</p><p>合并同类项，可得$2\cdot sum_j-sum_{g_j}\leq s_i$</p><p>令$d(j)=2sum_j-sum_{g_j}$，$g_i$表示满足条件的最大的$j$，即$g_i=\max\limits_{\sum\limits_{l=g_j}^{j}{a_l}\leq\sum\limits_{l=j+1}^{i}{a_l} }{ \{j\} }$</p><p>可以设想一下，如果$\exists x&lt;y,\ d(x)\leq s_i,\ d(y)\leq s_i$，按照分块尽量少的原则，肯定优先选择$y$</p><p>所以$g_i$具有单调性</p><p>因此我们可以维护一个单调队列，储存有用的决策点，其中$g_i$单调递增</p><p>当队首满足条件$d(q_{head})\leq sum_i$时，根据分块尽量少的原则，选择最后的满足条件的$q_{head}$更新$g_i$</p><p>当队尾不满足$d(q_{tail})&lt; d(i)$时，删除队尾</p><p>最后把当前点加入队列中</p><p>统计答案时，根据$g_i$往前跳即可</p><h5 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r &amp;&amp; sum[<span class="built_in">queue</span>[l + <span class="number">1</span>]] - sum[pre[<span class="built_in">queue</span>[l + <span class="number">1</span>]]] + sum[<span class="built_in">queue</span>[l + <span class="number">1</span>]] &lt;= sum[i])</span><br><span class="line">			++l;</span><br><span class="line">		pre[i] = <span class="built_in">queue</span>[l];</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r &amp;&amp; sum[<span class="built_in">queue</span>[r]] - sum[pre[<span class="built_in">queue</span>[r]]] + sum[<span class="built_in">queue</span>[r]] &gt;= sum[i] - sum[pre[i]] + sum[i])</span><br><span class="line">			--r;</span><br><span class="line">		<span class="built_in">queue</span>[++r] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> now = n;</span><br><span class="line">	__int128 ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (now)</span><br><span class="line">		ans += (sum[now] - sum[pre[now]]) * (sum[now] - sum[pre[now]]),</span><br><span class="line">		now = pre[now];</span><br></pre></td></tr></table></figure><h3 id="100pts"><a href="#100pts" class="headerlink" title="100pts"></a>100pts</h3><p>把$type=1$的点写上即可</p><p>记得写高精或者<code>__int128</code></p><p>省空间大法：$sum$前缀和数组重复使用</p><p>以及需要$O2$优化</p><h5 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fgcse"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fgcse-lm"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fipa-sra"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-pre"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-vrp"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fpeephole2"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ffast-math"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fsched-spec"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"unroll-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-labels"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fdevirtualize"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcaller-saves"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcrossjumping"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fthread-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-funroll-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fwhole-program"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-freorder-blocks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fschedule-insns"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-tail-merge"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fschedule-insns2"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fstrict-aliasing"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fstrict-overflow"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcse-skip-blocks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcse-follow-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fsched-interblock"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fpartial-inlining"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"no-stack-protector"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-freorder-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-findirect-inlining"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fhoist-adjacent-loads"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-frerun-cse-after-loop"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline-small-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-finline-small-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-switch-conversion"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-foptimize-sibling-calls"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fexpensive-optimizations"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-funsafe-loop-optimizations"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline-functions-called-once"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fdelete-null-pointer-checks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"inline"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fgcse"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fgcse-lm"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fipa-sra"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-ftree-pre"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-ftree-vrp"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fpeephole2"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-ffast-math"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fsched-spec"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"unroll-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-falign-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-falign-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-falign-labels"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fdevirtualize"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fcaller-saves"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fcrossjumping"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fthread-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-funroll-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fwhole-program"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-freorder-blocks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fschedule-insns"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"inline-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-ftree-tail-merge"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fschedule-insns2"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fstrict-aliasing"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fstrict-overflow"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-falign-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fcse-skip-blocks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fcse-follow-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fsched-interblock"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fpartial-inlining"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"no-stack-protector"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-freorder-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-findirect-inlining"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fhoist-adjacent-loads"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-frerun-cse-after-loop"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"inline-small-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-finline-small-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-ftree-switch-conversion"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-foptimize-sibling-calls"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fexpensive-optimizations"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-funsafe-loop-optimizations"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"inline-functions-called-once"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(<span class="meta-string">"-fdelete-null-pointer-checks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __int128 long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="keyword">int</span> n, type, l, r, m, p, <span class="built_in">queue</span>[<span class="number">40000001</span>], pre[<span class="number">40000001</span>], x, y, z;</span><br><span class="line">__int128 sum[<span class="number">40000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">write</span>(<span class="title">I</span> <span class="title">a</span>) &#123;</span></span><br><span class="line">	<span class="keyword">if</span> (a &gt; <span class="number">9</span>)</span><br><span class="line">		write(a / <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(a % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp; n, &amp; type);</span><br><span class="line">	<span class="keyword">if</span> (!type)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp; sum[i]),</span><br><span class="line">			sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%lld%lld%d"</span>, &amp; x, &amp; y, &amp; z, &amp; sum[<span class="number">1</span>], &amp; sum[<span class="number">2</span>], &amp; m);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)</span><br><span class="line">			sum[i] = (<span class="number">1L</span>L * x * sum[i - <span class="number">1</span>] + <span class="number">1L</span>L * y * sum[i - <span class="number">2</span>] + z) &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp; p, &amp; l, &amp; r);</span><br><span class="line">			<span class="keyword">for</span> (; j &lt;= p; ++j)</span><br><span class="line">				sum[j] = sum[j] % (r - l + <span class="number">1l</span>l) + l,</span><br><span class="line">				sum[j] += sum[j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	l = r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r &amp;&amp; sum[<span class="built_in">queue</span>[l + <span class="number">1</span>]] - sum[pre[<span class="built_in">queue</span>[l + <span class="number">1</span>]]] + sum[<span class="built_in">queue</span>[l + <span class="number">1</span>]] &lt;= sum[i])</span><br><span class="line">			++l;</span><br><span class="line">		pre[i] = <span class="built_in">queue</span>[l];</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r &amp;&amp; sum[<span class="built_in">queue</span>[r]] - sum[pre[<span class="built_in">queue</span>[r]]] + sum[<span class="built_in">queue</span>[r]] &gt;= sum[i] - sum[pre[i]] + sum[i])</span><br><span class="line">			--r;</span><br><span class="line">		<span class="built_in">queue</span>[++r] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> now = n;</span><br><span class="line">	__int128 ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (now)</span><br><span class="line">		ans += (sum[now] - sum[pre[now]]) * (sum[now] - sum[pre[now]]),</span><br><span class="line">		now = pre[now];</span><br><span class="line">	write(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完结！</p><p>全体起立！</p>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>数学笔记</title>
    <url>/math/</url>
    <content><![CDATA[<p>Oneton的数学笔记</p><a id="more"></a><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h2><h3 id="1-平面向量的概念"><a href="#1-平面向量的概念" class="headerlink" title="1.平面向量的概念"></a>1.平面向量的概念</h3><ul><li><p>向量: 既有<strong>大小</strong>又有<strong>方向</strong> (与矢量对应)</p></li><li><p>数量: 只有<strong>大小</strong>无<strong>方向</strong> (与标量对应)</p><p><em>向量不能比较大小</em></p></li></ul><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><ul><li><p>有向线段: 有起点, 终点, 长度 位置固定</p></li><li><p>向量可以平移</p></li></ul><h3 id="3-向量表示-overrightarrow-AB-overrightarrow-a-印刷-textbf-a"><a href="#3-向量表示-overrightarrow-AB-overrightarrow-a-印刷-textbf-a" class="headerlink" title="3.向量表示:  $\overrightarrow {AB}$,  $\overrightarrow {a}$(印刷:$\textbf{a}$ )"></a>3.向量表示: $\overrightarrow {AB}$, $\overrightarrow {a}$(印刷:$\textbf{a}$ )</h3><h3 id="4-模-大小-长度-记为-overrightarrow-AB-overrightarrow-a"><a href="#4-模-大小-长度-记为-overrightarrow-AB-overrightarrow-a" class="headerlink" title="4.模(大小, 长度), 记为 $|\overrightarrow {AB}|$, $|\overrightarrow {a}|$"></a>4.模(大小, 长度), 记为 $|\overrightarrow {AB}|$, $|\overrightarrow {a}|$</h3><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><ul><li><p>零向量: 长度为$0$ 记为$\overrightarrow {0}$, 方向任意;</p></li><li><p>单位向量: 长度为$1$, 与非零向量$\overrightarrow {a}$共线的向量$\pm \frac{\overrightarrow{a} }{|\overrightarrow{a}|}$</p></li></ul><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><ul><li><p>相等向量: 长度相同, 方向相同</p></li><li><p>平行向量: 等于共线向量</p><p>方向相同或相反的<strong>非零</strong>向量, 记$\overrightarrow{a}//\overrightarrow{b}$</p><p>$\overrightarrow{0}$与任意向量平行</p></li></ul><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><ul><li><p>直线线段平行$\neq$共线</p></li><li><p>向量平行$=$共线</p><p>注: $\overrightarrow{a}//\overrightarrow{b}, \overrightarrow{b}//\overrightarrow{c}$ 那么$\overrightarrow{a}=\overrightarrow{c}$ 错</p><p>​ $\overrightarrow{a}=\overrightarrow{b}, \overrightarrow{b}=\overrightarrow{c}$ 那么$\overrightarrow{a}=\overrightarrow{c}$ 对</p><p>四边形$ABCD$中, $\overrightarrow{AB}=\overrightarrow{CD}$, $ABCD$为平行四边形</p></li></ul><h2 id="6-2-1-加法"><a href="#6-2-1-加法" class="headerlink" title="6.2.1 加法"></a>6.2.1 加法</h2><h3 id="1-法则"><a href="#1-法则" class="headerlink" title="1. 法则"></a>1. 法则</h3><ul><li>平行四边形法则: 共起点</li></ul><p><img data-src="/images/math_1.png" alt="1"></p><ul><li>三角形法则: 首尾相连连首尾</li></ul><p><img data-src="/images/math_2.png" alt="2"></p><p>可直接出结果, 计算可无限推广</p><h3 id="2-overrightarrow-0-overrightarrow-a-overrightarrow-a"><a href="#2-overrightarrow-0-overrightarrow-a-overrightarrow-a" class="headerlink" title="2. $\overrightarrow{0}+\overrightarrow{a}=\overrightarrow{a}$"></a>2. $\overrightarrow{0}+\overrightarrow{a}=\overrightarrow{a}$</h3><h3 id="3-overrightarrow-a-overrightarrow-b-leq-overrightarrow-a-overrightarrow-b-leq-overrightarrow-a-overrightarrow-b"><a href="#3-overrightarrow-a-overrightarrow-b-leq-overrightarrow-a-overrightarrow-b-leq-overrightarrow-a-overrightarrow-b" class="headerlink" title="3. $||\overrightarrow{a}|-|\overrightarrow{b}||\leq |\overrightarrow{a}+\overrightarrow{b}|\leq |\overrightarrow{a}|+|\overrightarrow{b}|$"></a>3. $||\overrightarrow{a}|-|\overrightarrow{b}||\leq |\overrightarrow{a}+\overrightarrow{b}|\leq |\overrightarrow{a}|+|\overrightarrow{b}|$</h3><ul><li>$\overrightarrow{a}, \overrightarrow{b}$有一个为$\overrightarrow{0}$或都为$\overrightarrow{0}$, 则$||\overrightarrow{a}|-|\overrightarrow{b}||=|\overrightarrow{a}+\overrightarrow{b}|=|\overrightarrow{a}|+|\overrightarrow{b}|$</li><li>$\overrightarrow{a}, \overrightarrow{b}$反向, 则$||\overrightarrow{a}|-|\overrightarrow{b}||=|\overrightarrow{a}+\overrightarrow{b}|$</li><li>$\overrightarrow{a}, \overrightarrow{b}$同向, 则$|\overrightarrow{a}+\overrightarrow{b}|= |\overrightarrow{a}|+|\overrightarrow{b}|$</li><li>$\overrightarrow{a}, \overrightarrow{b}$不共线, 则 $||\overrightarrow{a}|-|\overrightarrow{b}||&lt; |\overrightarrow{a}+\overrightarrow{b}|&lt;|\overrightarrow{a}|+|\overrightarrow{b}|$</li></ul><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><ul><li>$\overrightarrow{a}+\overrightarrow{b}=\overrightarrow{b}+\overrightarrow{a}$</li><li>$(\overrightarrow{a}+\overrightarrow{b})+\overrightarrow{c}=\overrightarrow{a}+(\overrightarrow{b}+\overrightarrow{c})$</li></ul><h3 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h3><h4 id="1-作图-两个法则特点"><a href="#1-作图-两个法则特点" class="headerlink" title="1. 作图: 两个法则特点"></a>1. 作图: 两个法则特点</h4><h4 id="2-运算-字母间的变换"><a href="#2-运算-字母间的变换" class="headerlink" title="2. 运算: 字母间的变换"></a>2. 运算: 字母间的变换</h4><p>e.g.:<script type="math/tex">\overrightarrow{AB}+\overrightarrow{DF}+\overrightarrow{CD}+\overrightarrow{BC}+\overrightarrow{FA}=\overrightarrow{0}</script></p><h4 id="3-实际应用"><a href="#3-实际应用" class="headerlink" title="3.实际应用"></a>3.实际应用</h4><ul><li>垂直到达岸边<img data-src="/images/math_3.png" alt="3"></li><li>沿垂直方向走<img data-src="/images/math_4.png" alt="4"></li></ul><h2 id="6-2-2减法"><a href="#6-2-2减法" class="headerlink" title="6.2.2减法"></a>6.2.2减法</h2><h3 id="1-相反向量"><a href="#1-相反向量" class="headerlink" title="1.相反向量"></a>1.相反向量</h3><ul><li>相反向量: <strong>长度</strong>相等, 方向相反</li><li>$\overrightarrow{AB}$的相反向量为$\overrightarrow{BA}=-\overrightarrow{AB}$</li><li>$\overrightarrow{0}$的相反向量为$\overrightarrow{0}$</li></ul><h3 id="2-三角形法则-共起点-连终点-方向指向被减数"><a href="#2-三角形法则-共起点-连终点-方向指向被减数" class="headerlink" title="2.三角形法则: 共起点, 连终点, 方向指向被减数"></a>2.三角形法则: 共起点, 连终点, 方向指向被减数</h3><ul><li><img data-src="/images/math_5.png" alt="5">$\overrightarrow{OA}-\overrightarrow{OB}=\overrightarrow{BA}$</li></ul><h3 id="3-overrightarrow-a-overrightarrow-b-leq-overrightarrow-a-pm-overrightarrow-b-leq-overrightarrow-a-overrightarrow-b"><a href="#3-overrightarrow-a-overrightarrow-b-leq-overrightarrow-a-pm-overrightarrow-b-leq-overrightarrow-a-overrightarrow-b" class="headerlink" title="3.$||\overrightarrow{a}|-|\overrightarrow{b}||\leq |\overrightarrow{a}\pm\overrightarrow{b}|\leq |\overrightarrow{a}|+|\overrightarrow{b}|$"></a>3.$||\overrightarrow{a}|-|\overrightarrow{b}||\leq |\overrightarrow{a}\pm\overrightarrow{b}|\leq |\overrightarrow{a}|+|\overrightarrow{b}|$</h3><ul><li>$\overrightarrow{a},\overrightarrow{b}$至少有一个为时, 等号同时成立</li><li>$\overrightarrow{a},\overrightarrow{b}$同向且$|\overrightarrow{a}|&gt;|\overrightarrow{b}|$时, $|\overrightarrow{a}-\overrightarrow{b}|=|\overrightarrow{a}|-|\overrightarrow{b}|$</li><li>$\overrightarrow{a},\overrightarrow{b}$同向且$|\overrightarrow{a}|&lt;|\overrightarrow{b}|$时, $|\overrightarrow{a}-\overrightarrow{b}|=|\overrightarrow{a}|-|\overrightarrow{b}|$</li><li>$\overrightarrow{a},\overrightarrow{b}$反向时, $|\overrightarrow{a}-\overrightarrow{b}|=|\overrightarrow{a}|+|\overrightarrow{b}|$</li><li>$\overrightarrow{a},\overrightarrow{b}$不共线时, $||\overrightarrow{a}|-|\overrightarrow{b}||&lt; |\overrightarrow{a}-\overrightarrow{b}|&lt;|\overrightarrow{a}|+|\overrightarrow{b}|$</li></ul><h3 id="题型-1"><a href="#题型-1" class="headerlink" title="题型"></a>题型</h3><h4 id="1-做图"><a href="#1-做图" class="headerlink" title="1. 做图"></a>1. 做图</h4><ul><li>化成加减法</li><li>三角形法则</li></ul><h4 id="2-化简"><a href="#2-化简" class="headerlink" title="2. 化简"></a>2. 化简</h4><ul><li><p>化成加法</p></li><li><p>三角形法则</p></li><li><p>注意字母间变换</p><h5 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h5><ul><li><p>$\overrightarrow{NQ}-\overrightarrow{PQ}-\overrightarrow{NM}-\overrightarrow{MP}$<br>$=\overrightarrow{NQ}+\overrightarrow{QP}+\overrightarrow{MN}-\overrightarrow{MP}=\overrightarrow{0}$</p><p>或$=(\overrightarrow{NQ}-\overrightarrow{NM})-(\overrightarrow{PQ}+\overrightarrow{MP})=\overrightarrow{0}$</p></li><li><p>$(\overrightarrow{AB}-\overrightarrow{CD})-(\overrightarrow{AC}-\overrightarrow{BD})$<br>$=\overrightarrow{AB}+\overrightarrow{DC}+\overrightarrow{CA}+\overrightarrow{BD}=\overrightarrow{0}$</p><p>或$=\overrightarrow{AB}-\overrightarrow{AC}-\overrightarrow{CD}+\overrightarrow{BD}=\overrightarrow{0}$</p></li></ul></li></ul><h4 id="3-表示向量"><a href="#3-表示向量" class="headerlink" title="3.表示向量"></a>3.表示向量</h4><h5 id="e-g-1"><a href="#e-g-1" class="headerlink" title="e.g."></a>e.g.</h5><ul><li>如图, 五边形$ABCDE$中, 四边形$ACDE$是平行四边形, 用$\textbf{a,b,c}$表示$\overrightarrow{BD},\overrightarrow{BC},\overrightarrow{BE},\overrightarrow{CD},\overrightarrow{CE}$ <img data-src="/images/math_6.png" alt="6"></li></ul><h2 id="6-2-3-数乘"><a href="#6-2-3-数乘" class="headerlink" title="6.2.3 数乘"></a>6.2.3 数乘</h2><h3 id="1-实数-lambda-cdot-overrightarrow-a"><a href="#1-实数-lambda-cdot-overrightarrow-a" class="headerlink" title="1.实数$\lambda\cdot\overrightarrow{a}$"></a>1.实数$\lambda\cdot\overrightarrow{a}$</h3><ul><li>$|\lambda\overrightarrow{a}|=|\lambda||\overrightarrow{a}$</li><li>$\lambda\overrightarrow{a}(\overrightarrow{a}\ne\overrightarrow{0})$<ul><li>$\lambda&gt;0$ 时, 与$\overrightarrow{a}$同向</li><li>$\lambda&lt;0$ 时, 与$\overrightarrow{a}$反向</li></ul></li><li>$\lambda=0$或$\overrightarrow{a}=0$时, $\lambda\overrightarrow{a}=\overrightarrow{0}$</li></ul><h3 id="2-运算法则"><a href="#2-运算法则" class="headerlink" title="2. 运算法则"></a>2. 运算法则</h3><ul><li>加法, 减法, 数乘: 线性运算</li></ul><h3 id="3-共线向量定理"><a href="#3-共线向量定理" class="headerlink" title="3.共线向量定理"></a>3.共线向量定理</h3><ul><li>共线向量定理: 向量$\overrightarrow{a}(\overrightarrow{a}\ne\overrightarrow{0})$与$\overrightarrow{b}$共线的充要条件是: 存在一个实数$\lambda$, 使$\overrightarrow{b}=\lambda\overrightarrow{a}$</li><li>$\overrightarrow{a}\ne\overrightarrow{0},\overrightarrow{a}//\overrightarrow{b}\Leftrightarrow\overrightarrow{b}=\lambda\overrightarrow{a}$</li><li>$\overrightarrow{a}\ne\overrightarrow{0}$不能去, 若$\overrightarrow{a}=\overrightarrow{0}$<ul><li>$\overrightarrow{b}=\overrightarrow{0}, \lambda$ 无解</li><li>$\overrightarrow{b}\ne\overrightarrow{0}, \lambda$ 无限解</li></ul></li></ul><h3 id="题型-2"><a href="#题型-2" class="headerlink" title="题型"></a>题型</h3><h4 id="1-化简-把向量当同类项"><a href="#1-化简-把向量当同类项" class="headerlink" title="1. 化简: 把向量当同类项"></a>1. 化简: 把向量当同类项</h4><h4 id="2-证明共线-overrightarrow-a-lambda-overrightarrow-b-三点共线-overrightarrow-AB-lambda-overrightarrow-AC-overrightarrow-AC-lambda-overrightarrow-BC"><a href="#2-证明共线-overrightarrow-a-lambda-overrightarrow-b-三点共线-overrightarrow-AB-lambda-overrightarrow-AC-overrightarrow-AC-lambda-overrightarrow-BC" class="headerlink" title="2.证明共线: $\overrightarrow{a}=\lambda\overrightarrow{b}$:三点共线: $\overrightarrow{AB}=\lambda\overrightarrow{AC}\\\overrightarrow{AC}=\lambda\overrightarrow{BC}$"></a>2.证明共线: $\overrightarrow{a}=\lambda\overrightarrow{b}$:三点共线: $\overrightarrow{AB}=\lambda\overrightarrow{AC}\\\overrightarrow{AC}=\lambda\overrightarrow{BC}$</h4><ul><li><p>e.g.</p><ul><li><p>$\overrightarrow{e_1}, \overrightarrow{e_2}$不共线</p><p>(1). $\overrightarrow{a}=\frac{1}{2}\overrightarrow{e_1}-\frac{1}{3}\overrightarrow{e_2}, \overrightarrow{b}=3\overrightarrow{e_1}-2\overrightarrow{e_2}$, 判断$\overrightarrow{a},\overrightarrow{b}$是否共线</p><p>​ $\because\overrightarrow{b}=6\overrightarrow{a}\therefore\overrightarrow{a}//\overrightarrow{b}$</p><p>(2). $\overrightarrow{AB}=\overrightarrow{e_1}+\overrightarrow{e_2},\overrightarrow{BC}=2\overrightarrow{e_1}+8\overrightarrow{e_2},\overrightarrow{CD}=3(\overrightarrow{e_1}-\overrightarrow{e_2})$, 求证: $A,B,C$三点共线</p><p>​<script type="math/tex">\begin{align*}
&\overrightarrow{AB}=\overrightarrow{e_1}+\overrightarrow{e_2}&\\
&\overrightarrow{BD}=5\overrightarrow{e_1}+5\overrightarrow{e_2}&\\
\because &\overrightarrow{AB}=5\overrightarrow{BD}&\\
\therefore &\overrightarrow{AB}//\overrightarrow{BD}&\\
又\because&B为中间点\\
\therefore &三点共线\\
\end{align*}</script></p></li></ul><p>$A,B,C$三点共线, $O$为任意一点<script type="math/tex">\Leftrightarrow\begin{align*}
\overrightarrow{OA}&=\lambda\overrightarrow{OB}+\mu\overrightarrow{OC}&\lambda+\mu=1\\
或\overrightarrow{OB}&=m\overrightarrow{OA}+n\overrightarrow{OC}&m+n=1\\
或\overrightarrow{OC}&=x\overrightarrow{OA}+y\overrightarrow{OB}&x+y=1\\
\end{align*}</script></p><script type="math/tex;mode=display">\begin{align*}
    证:&设\overrightarrow{AB}=\zeta\overrightarrow{AC}&设\overrightarrow{OB}&=m\overrightarrow{OA}+n\overrightarrow{OC}\quad  m+n=1\\
    &\overrightarrow{AO}+\overrightarrow{OB}=\zeta(\overrightarrow{AO}+\overrightarrow{OC})&&=m\overrightarrow{OA}+(1-m)\overrightarrow{OC}&\\
    &\overrightarrow{OB}=-\overrightarrow{AO}+\zeta\overrightarrow{AO}+\zeta\overrightarrow{OC}&&=m\overrightarrow{OA}-m\overrightarrow{OC}+\overrightarrow{OC}&\\
    &\ \ \ \ \ \ \ =(1-\zeta)\overrightarrow{OA}+\zeta\overrightarrow{OC}&&\overrightarrow{OB}-\overrightarrow{OC}=m(\overrightarrow{OA}-\overrightarrow{OC})&\\
    &&&\overrightarrow{CB}=m\overrightarrow{CA}&\\
    \end{align*}</script></li></ul><p>$\overrightarrow{e_1},\overrightarrow{e_2}$不共线, 且$\lambda_1\overrightarrow{e_1}=\lambda_2\overrightarrow{e_2}或\lambda_1\overrightarrow{e_1}+\lambda_2\overrightarrow{e_2}=0$则$\lambda_1=\lambda_2=0$</p><p>$\triangle ABC$中, $G$为重心, 则$\overrightarrow{GA}+\overrightarrow{GB}+\overrightarrow{GC}=\overrightarrow{0}$</p><h4 id="3-共线求参"><a href="#3-共线求参" class="headerlink" title="3. 共线求参"></a>3. 共线求参</h4><ul><li><p>e.g</p><ul><li><p>$\overrightarrow{e_1},\overrightarrow{e_2}$不共线, 使$k\overrightarrow{e_1}+\overrightarrow{e_2}$与$\overrightarrow{e_1}+k\overrightarrow{e_2}$共线, 求$k$</p><p>$设ke_1+\overrightarrow{e_2}=\lambda(\overrightarrow{e_1}+ke_2)\\<br>\therefore(k-\lambda)\overrightarrow{e_1}=(\lambda k-1)\overrightarrow{e_2}\\<br>\because \overrightarrow{e_1},\overrightarrow{e_2}不共线\\<br>\therefore \begin{cases}k-\lambda=0\\\lambda k-1=0\end{cases} \Rightarrow\begin{cases}k=1\\\lambda=1\end{cases} 或 \begin{cases}k=-1\\\lambda=-1\end{cases}\\<br>\therefore k=\pm1$</p></li></ul></li></ul><h3 id="4-表示-begin-cases-直接表示出来-等式解出来-end-cases"><a href="#4-表示-begin-cases-直接表示出来-等式解出来-end-cases" class="headerlink" title="4. 表示$\begin{cases}直接表示出来\\等式解出来\end{cases}$"></a>4. 表示$\begin{cases}直接表示出来\\等式解出来\end{cases}$</h3><ul><li><p>e.g</p><ul><li><p>$A,B,C$三点共线, $\overrightarrow{AC}=-3\overrightarrow{CB}$, 用$\overrightarrow{OA},\overrightarrow{OB}$表示$\overrightarrow{OC}=$<strong><strong>____</strong></strong></p><script type="math/tex;mode=display">\begin{align*}
法一:\overrightarrow{OC}&=\overrightarrow{OA}+\overrightarrow{AC}&法二:\overrightarrow{OC}&=\overrightarrow{OA}+\overrightarrow{AC}\\
&=\overrightarrow{OA}+\frac{3}{2}\overrightarrow{AB}&&=\overrightarrow{OA}+3\overrightarrow{BC}\\
&=\overrightarrow{OA}+\frac{3}{2}(\overrightarrow{OB}-\overrightarrow{OA})&&=\overrightarrow{OA}+3(\overrightarrow{OC}-\overrightarrow{OB})\\
&=-\frac{1}{2}\overrightarrow{OA}+\frac{3}{2}\overrightarrow{OB}&&=\overrightarrow{OA}+3\overrightarrow{OC}-3\overrightarrow{OB}\\
&&&解得\overrightarrow{OC}=-\frac{1}{2}\overrightarrow{OA}+\frac{3}{2}\overrightarrow{OB}
\end{align*}</script></li><li><p>$\triangle ABC$及平面内一点$P$, 且$\overrightarrow{PA}+\overrightarrow{PB}+\overrightarrow{PC}=\overrightarrow{AB}$, 则$P$在<u>$AC$上</u></p><p>$\begin{align<em>}<br>\overrightarrow{PA}+\overrightarrow{PC}&amp;=\overrightarrow{AP}&amp;\\<br>\overrightarrow{PC}&amp;=2\overrightarrow{AP}&amp;\\<br>\therefore P在AC上\\<br>\end{align</em>}$</p></li></ul></li></ul><h3 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h3><ul><li><p>如图所示, 已知点$G$是$\triangle ABC$ 的重心, 过点$G$作直线与$AB,AC$两边分别交于$M,N$两点, 且$\overrightarrow{AM}=x\overrightarrow{AB},\overrightarrow{AN}=y\overrightarrow{AC}$则$x+y$的最小值为<img data-src="/images/math_7.png" alt="7"></p><script type="math/tex;mode=display">\begin{align*}
&\overrightarrow{AB}=\frac{1}{x}\overrightarrow{AM},\overrightarrow{AC}=\frac{1}{y}\overrightarrow{AM}\\
&\overrightarrow{AB}+\overrightarrow{AC}=2\overrightarrow{AQ}=2\cdot\frac{3}{2}\overrightarrow{AG}=3\overrightarrow{AG}\\
\therefore\ &\overrightarrow{AG}=\frac{1}{3}(\frac{1}{x}\overrightarrow{AM}+\frac{1}{y}\overrightarrow{AN})=\frac{1}{3x}\overrightarrow{AM}+\frac{1}{3y}\overrightarrow{AN}\\
又\because\ &M,G,N共线\\
\therefore\ &\frac{1}{3x}+\frac{1}{3y}=1\\
\therefore\ &x+y=(x+y)\cdot(\frac{1}{3x}+\frac{1}{3y})=\frac{2}{3}+\frac{x}{3y}+\frac{y}{3x}\geq\frac{4}{3}\\
&当且仅当\frac{x}{3y}=\frac{y}{3x},即x=\pm y时,等号成立
\end{align*}</script></li><li><p>在$\triangle ABC$中, 若点$P,Q$为线段$BC$的两个黄金分割点, 设$\overrightarrow{AP}=x_1\overrightarrow{AB}+y_1\overrightarrow{AC},\overrightarrow{AQ}=x_2\overrightarrow{AB}+y_2\overrightarrow{AC}$, 则$\frac{x_1}{x_2}+\frac{y_1}{y_2}=\qquad$<img data-src="/images/math_8.png" alt="8"></p><script type="math/tex;mode=display">\begin{align*}
&\overrightarrow{AP}=\overrightarrow{AB}+\overrightarrow{BP}=\overrightarrow{AB}+\frac{3-\sqrt{5} }{2}\overrightarrow{BC}=\overrightarrow{AB}+\frac{3-\sqrt{5} }{2}(\overrightarrow{AC}-\overrightarrow{AB})=\frac{\sqrt{5}-1}{2}\overrightarrow{AB}+\frac{3-\sqrt{5} }{2}\overrightarrow{AC} \\
同理,&\overrightarrow{AQ}=\frac{3-\sqrt{5} }{2}\overrightarrow{AB}+\frac{\sqrt{5}-1}{2}\overrightarrow{AC}\\
\therefore\ &\frac{x_1}{x_2}+\frac{y_1}{y_2}=\sqrt{5}
\end{align*}</script></li></ul><h2 id="6-2-4向量的数量积"><a href="#6-2-4向量的数量积" class="headerlink" title="6.2.4向量的数量积"></a>6.2.4向量的数量积</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><ul><li>$\overrightarrow{a},\overrightarrow{b}$为非零向量, $\overrightarrow{a},\overrightarrow{b}$夹角为$\theta$</li><li>$\theta=0$, $\overrightarrow{a},\overrightarrow{b}$同向</li><li>$\theta=\pi$, $\overrightarrow{a},\overrightarrow{b}$反向</li><li>$\theta=\frac{1}{2}\pi$, $\overrightarrow{a}\perp\overrightarrow{b}$</li><li>$\overrightarrow{a}\cdot \overrightarrow{b}=|\overrightarrow{a}|\cdot|\overrightarrow{b}|\cos{\theta}$</li><li>$\overrightarrow{0}$与任一向量的乘积都为0</li><li>数量积结果是实数, 向量线性运算结果是向量</li></ul><h3 id="2-投影向量"><a href="#2-投影向量" class="headerlink" title="2. 投影向量"></a>2. 投影向量</h3><ul><li><img data-src="/images/math_9.png" alt="9"> $\overrightarrow{a}$在$\overrightarrow{b}$方向上的投影向量$\overrightarrow{OC}=|\overrightarrow{a}|\cos{\theta}\cdot\frac{\overrightarrow{b} }{|\overrightarrow{b}|}$</li></ul><h3 id="3-overrightarrow-a-overrightarrow-b-为非零向量"><a href="#3-overrightarrow-a-overrightarrow-b-为非零向量" class="headerlink" title="3. $\overrightarrow{a},\overrightarrow{b}$为非零向量"></a>3. $\overrightarrow{a},\overrightarrow{b}$为非零向量</h3><ul><li>$\overrightarrow{a},\overrightarrow{b}$同向, $\overrightarrow{a}\cdot \overrightarrow{b}=|\overrightarrow{a}|\cdot|\overrightarrow{b}|$</li><li>$\overrightarrow{a},\overrightarrow{b}$反向, $\overrightarrow{a}\cdot \overrightarrow{b}=-|\overrightarrow{a}|\cdot|\overrightarrow{b}|$</li><li>$\overrightarrow{a}\perp \overrightarrow{b}$, $\overrightarrow{a}\cdot \overrightarrow{b}=0$</li><li>$|\overrightarrow{a}\cdot \overrightarrow{b}|\leq|\overrightarrow{a}|\cdot|\overrightarrow{b}|$</li><li>$|\overrightarrow{a}|=\sqrt{\overrightarrow{a}^2}$</li></ul><h3 id="4-运算"><a href="#4-运算" class="headerlink" title="4. 运算"></a>4. 运算</h3><ul><li>$\overrightarrow{a}\cdot \overrightarrow{b}=\overrightarrow{b}\cdot \overrightarrow{a}$</li><li>$\lambda \overrightarrow{a}\cdot \overrightarrow{b}=\lambda(\overrightarrow{a}\cdot \overrightarrow{b})=\overrightarrow{a}\cdot(\lambda \overrightarrow{b})$</li><li>$(\overrightarrow{a}+\overrightarrow{b})\cdot\overrightarrow{c}=\overrightarrow{a}\cdot \overrightarrow{c}+\overrightarrow{b}\cdot \overrightarrow{c}$</li><li>$(\overrightarrow{a}+\overrightarrow{b})(\overrightarrow{a}-\overrightarrow{b})=\overrightarrow{a}^2-\overrightarrow{b}^2=|\overrightarrow{a}|^2-|\overrightarrow{b}|^2$</li><li>$(\overrightarrow{a}\pm \overrightarrow{b})^2=a^2\pm2\overrightarrow{a}\overrightarrow{b}+\overrightarrow{b}^2$</li></ul><h3 id="5-overrightarrow-a-overrightarrow-b-overrightarrow-c-非-overrightarrow-0"><a href="#5-overrightarrow-a-overrightarrow-b-overrightarrow-c-非-overrightarrow-0" class="headerlink" title="5. $\overrightarrow{a},\overrightarrow{b},\overrightarrow{c}$非$\overrightarrow{0}$"></a>5. $\overrightarrow{a},\overrightarrow{b},\overrightarrow{c}$非$\overrightarrow{0}$</h3><ul><li><p>$\overrightarrow{a}\cdot \overrightarrow{b}=\overrightarrow{b}\cdot \overrightarrow{c}\Rightarrow \overrightarrow{a}=\overrightarrow{c}\qquad\times$ 只能说明$\overrightarrow{a}$和$\overrightarrow{c}$的投影相等</p><script type="math/tex;mode=display">\begin{align*}
|\overrightarrow{a}|\cdot|\overrightarrow{b}|\cos{\theta_1}&=|\overrightarrow{b}|\cdot|\overrightarrow{c}|\cos{\theta_2}\\
|\overrightarrow{a}|\cdot\cos{\theta_1}&=|\overrightarrow{c}|\cos{\theta_2}
\end{align*}</script></li><li><p>$\overrightarrow{a}\cdot \overrightarrow{b}\cdot \overrightarrow{c}=\overrightarrow{a}\cdot(\overrightarrow{b}\cdot \overrightarrow{c})\qquad\times$</p><script type="math/tex;mode=display">\begin{align*}
|\overrightarrow{a}|\cdot|\overrightarrow{b}|\cos{\theta_1}\cdot\overrightarrow{c}=\overrightarrow{a}\cdot(|\overrightarrow{b}|\cdot|\overrightarrow{c}|\cos{\theta_2})
\end{align*}</script></li></ul><h3 id="题型-3"><a href="#题型-3" class="headerlink" title="题型"></a>题型</h3><h4 id="1-求向量的模-begin-cases-已知-2a-b-amp-两边平方-求-2a-b-amp-sqrt-2a-b-2-end-cases"><a href="#1-求向量的模-begin-cases-已知-2a-b-amp-两边平方-求-2a-b-amp-sqrt-2a-b-2-end-cases" class="headerlink" title="1. 求向量的模$\begin{cases}已知|2a+b|&amp;两边平方\\求|2a+b|&amp;=\sqrt{(2a+b)^2}\end{cases}$"></a>1. 求向量的模$\begin{cases}已知|2a+b|&amp;两边平方\\求|2a+b|&amp;=\sqrt{(2a+b)^2}\end{cases}$</h4><ul><li><p>e.g.</p><ul><li>已知$|\overrightarrow{a}|=|\overrightarrow{b}|=5$, 且$|3\overrightarrow{a}-2\overrightarrow{b}|=5$, 求$|3\overrightarrow{a}-2\overrightarrow{b}|$的值</li></ul></li></ul><h4 id="2-求夹角"><a href="#2-求夹角" class="headerlink" title="2. 求夹角"></a>2. 求夹角</h4><ul><li><p>e.g.</p><ul><li>设$\overrightarrow{m},\overrightarrow{n}$是两个单位向量, 其夹角是$60^\circ$, 求向量$\overrightarrow{a}=2\overrightarrow{m}+\overrightarrow{n}$与$\overrightarrow{b}=2\overrightarrow{n}-3\overrightarrow{m}$的夹角</li></ul></li></ul><h4 id="3-夹角为锐-钝角"><a href="#3-夹角为锐-钝角" class="headerlink" title="3. 夹角为锐/钝角"></a>3. 夹角为锐/钝角</h4><ul><li><p>锐角$\Leftrightarrow\begin{cases}\overrightarrow{a}\cdot \overrightarrow{b}&gt;0\\\overrightarrow{a}\cdot \overrightarrow{b}不同向平行\end{cases}$</p></li><li><p>钝角$\Leftrightarrow\begin{cases}\overrightarrow{a}\cdot \overrightarrow{b}&lt;0\\\overrightarrow{a}\cdot \overrightarrow{b}不反向平行\end{cases}$</p></li><li><p>e.g.</p><ul><li><p>已知$\overrightarrow{e_1},\overrightarrow{e_2}$是两个互相垂直的单位向量, 若向量$\overrightarrow{e_1}+k\overrightarrow{e_2}$与$k\overrightarrow{e_1}+\overrightarrow{e_2}$夹角问锐角, 则$k$的取值范围为</p></li><li><p>设两个向量$\overrightarrow{e_1},\overrightarrow{e_2}$满足$|\overrightarrow{e_1}|=2,|\overrightarrow{e_2}|=1,\overrightarrow{e_1},\overrightarrow{e_2}$夹角为$60^\circ$, 若向量$2t\overrightarrow{e_1}+7\overrightarrow{e_2}$与$\overrightarrow{e_1}+t\overrightarrow{e_2}$夹角为钝角, 求$t$取值范围</p></li></ul></li></ul><h2 id="6-3-1-平面向量基本定理"><a href="#6-3-1-平面向量基本定理" class="headerlink" title="6.3.1 平面向量基本定理"></a>6.3.1 平面向量基本定理</h2><h3 id="1-平面向量定理"><a href="#1-平面向量定理" class="headerlink" title="1. 平面向量定理"></a>1. 平面向量定理</h3><ul><li>如果$\overrightarrow{e_1},\overrightarrow{e_2}$是同一平面内的两个<strong>不共线</strong>向量, 那么对于这一平面内的<strong>任意</strong>向量$\overrightarrow{a}$, <strong>有且只有一对</strong>实数$\lambda_1,\lambda_2$, 使$\overrightarrow{a}=\lambda_1\overrightarrow{e_1}+\lambda_2\overrightarrow{e_2}$</li></ul><h3 id="2-基底"><a href="#2-基底" class="headerlink" title="2. 基底"></a>2. 基底</h3><ul><li><p><strong>不共线</strong>的向量$\overrightarrow{e_1},\overrightarrow{e_2}$叫做表示这一平面<strong>所有</strong>向量的一组基底</p></li><li><p>一个平面内有无数组基底</p></li></ul><h3 id="3-overrightarrow-e-1-overrightarrow-e-2-是一组基底"><a href="#3-overrightarrow-e-1-overrightarrow-e-2-是一组基底" class="headerlink" title="3. $\overrightarrow{e_1},\overrightarrow{e_2}$是一组基底"></a>3. $\overrightarrow{e_1},\overrightarrow{e_2}$是一组基底</h3><ul><li><p>任意向量$a=\lambda_1\overrightarrow{e_1}+\lambda_2\overrightarrow{e_2}$, $\lambda_1,\lambda_2$有且只有一对</p></li><li><p>$a=\lambda_1\overrightarrow{e_1}+\lambda_2\overrightarrow{e_2}(\lambda_1,\lambda_2\in\mathbb{R})$表示了平面内所有向量</p></li></ul><h3 id="4-overrightarrow-e-1-overrightarrow-e-2-是一组基底"><a href="#4-overrightarrow-e-1-overrightarrow-e-2-是一组基底" class="headerlink" title="4. $\overrightarrow{e_1},\overrightarrow{e_2}$是一组基底"></a>4. $\overrightarrow{e_1},\overrightarrow{e_2}$是一组基底</h3><ul><li><p>若$x_1\overrightarrow{e_1}+y_1\overrightarrow{e_2}=x_2\overrightarrow{e_1}+y_2\overrightarrow{e_2}$, 则$x_1=x_2,y_1=y_2$</p></li><li><p>$\lambda_1\overrightarrow{e_1}+\lambda_2\overrightarrow{e_2}=\overrightarrow{0}$, 则$\lambda_1=\lambda_2=0$</p></li></ul><h3 id="题型-4"><a href="#题型-4" class="headerlink" title="题型"></a>题型</h3><ul><li><p>e.g.</p><ul><li><p>用$\overrightarrow{DE},\overrightarrow{BF}$表示$\overrightarrow{AB},\overrightarrow{AD}$ <img data-src="//imagess/math_10.png" alt="10"></p></li><li><p>在$\triangle AOB$中, $\overrightarrow{OA}=\overrightarrow{a},\overrightarrow{OB}=\overrightarrow{b},M,N$分别是边$OA,OB$上的点, 且$\overrightarrow{OM}=\frac{1}{3}\overrightarrow{a},\overrightarrow{ON}=\frac{1}{2}\overrightarrow{b}$, 设$AN$与$BM$交于点$P$, 用$\overrightarrow{a},\overrightarrow{b}$表示$\overrightarrow{OP}$ <img data-src="//imagess/math_11.png" alt="11">$$</p></li></ul></li></ul><script type="math/tex;mode=display">\begin{align*}
法一:\overrightarrow{OP}&=\overrightarrow{OA}+\overrightarrow{AP}&法二:&设\overrightarrow{AP}=\lambda\overrightarrow{AN}&法三:&设\overrightarrow{OP}=m\overrightarrow{OA}+n\overrightarrow{OB}\\
                   &=\overrightarrow{OA}+\frac{4}{5}\overrightarrow{AN}&&\overrightarrow{OP}-\overrightarrow{OA}=\lambda(\overrightarrow{ON}-\overrightarrow{OA})&&A,P,N共线\Rightarrow\overrightarrow{AP}=\overrightarrow{OP}-\overrightarrow{OA}=(m-1)\overrightarrow{OA}+n\overrightarrow{OB},\overrightarrow{AN}=\overrightarrow{ON}-\overrightarrow{OA}=-\overrightarrow{OA}+\frac{1}{2}\overrightarrow{OB}\\
                   &=\frac{1}{5}\overrightarrow{OA}+\frac{4}{5}\cdot\frac{1}{2}\overrightarrow{OA}&&设\overrightarrow{BP}=\mu\overrightarrow{BM}&&\frac{m-1}{-1}=\frac{n}{\frac{1}{2} }\Rightarrow m+2n-1=0\\
                   &=\frac{1}{5}\overrightarrow{OA}+\frac{2}{5}\overrightarrow{OB}&&\overrightarrow{OP}-\overrightarrow{OB}=\mu(\overrightarrow{OM}-\overrightarrow{OB})&&B,M,P共线\Rightarrow\overrightarrow{BP}=\overrightarrow{OP}-\overrightarrow{OB}=m\overrightarrow{OA}+(n-1)\overrightarrow{OB},\overrightarrow{BM}=\frac{1}{3}\overrightarrow{OA}-\overrightarrow{OB}\\
                   &&\therefore\ &\overrightarrow{OP}=\frac{\mu}{3}\overrightarrow{OA}+(1-\mu)\overrightarrow{OB}&&\frac{m}{\frac{1}{3} }=\frac{n-1}{-1}\Rightarrow3m+n-1=0\\
                   &&\therefore\ &\begin{cases}1-\lambda=\frac{\mu}{3}\\\frac{\lambda}{2}=1-\mu\\\end{cases}\ \Rightarrow\ \mu=\frac{3}{5}&&解得\ m=\frac{1}{5}\quad n=\frac{2}{5}\\
                   &&\therefore\ &\overrightarrow{OP}=\frac{1}{5}\overrightarrow{OA}+\frac{2}{5}\overrightarrow{OB}&&\therefore\ \overrightarrow{OP}=\frac{1}{5}\overrightarrow{OA}+\frac{2}{5}\overrightarrow{OB}\\
\end{align*}</script><h2 id="6-3-2-平面向量的正交分解及座标表示-amp-6-3-3-平面向量的坐标运算-amp-6-3-4-数乘的坐标表示"><a href="#6-3-2-平面向量的正交分解及座标表示-amp-6-3-3-平面向量的坐标运算-amp-6-3-4-数乘的坐标表示" class="headerlink" title="6.3.2 平面向量的正交分解及座标表示 &amp; 6.3.3 平面向量的坐标运算 &amp; 6.3.4 数乘的坐标表示"></a>6.3.2 平面向量的正交分解及座标表示 &amp; 6.3.3 平面向量的坐标运算 &amp; 6.3.4 数乘的坐标表示</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><ul><li><p>$\overrightarrow{a}=x\overrightarrow{i}+y\overrightarrow{j}$</p></li><li><p>$\overrightarrow{i}=(1,0),\overrightarrow{j}=(0,1), \overrightarrow{0}=(0,0)$</p></li></ul><h3 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.</h3><ul><li>$A(x,y),\overrightarrow{a}=(x,y)$</li></ul><h3 id="3-overrightarrow-a-x-1-y-1-overrightarrow-b-x-2-y-2"><a href="#3-overrightarrow-a-x-1-y-1-overrightarrow-b-x-2-y-2" class="headerlink" title="3. $\overrightarrow{a}=(x_1,y_1),\overrightarrow{b}=(x_2,y_2)$"></a>3. $\overrightarrow{a}=(x_1,y_1),\overrightarrow{b}=(x_2,y_2)$</h3><ul><li><p>$\overrightarrow{a}+\overrightarrow{b}=(x_1+x_2,y_1+y_2)$</p></li><li><p>$\overrightarrow{a}-\overrightarrow{b}=(x_2-x_1,y_2-y_1)$ (终点坐标-始点坐标)</p></li><li><p>$\overrightarrow{a}//\overrightarrow{b}\Leftrightarrow x_1y_2-x_2y_1=0$</p></li></ul><h3 id="4-1"><a href="#4-1" class="headerlink" title="4."></a>4.</h3><ul><li><p>$G$为$\triangle ABC$重心, $A(x_1,y_1), B(x_2,y_2), C(x_3,y_3)$, 则$\overrightarrow{GA}+\overrightarrow{GB}+\overrightarrow{GC}=\overrightarrow{0},G(\frac{x_1+x_2+x_3}{3},\frac{y_1+y_2+y_3}{3}), 3\overrightarrow{PG}=\overrightarrow{PA}+\overrightarrow{PB}+\overrightarrow{PC}=\overrightarrow{PG}+\overrightarrow{GA}+\overrightarrow{PG}+\overrightarrow{GB}+\overrightarrow{PG}+\overrightarrow{GC}$</p></li><li><p>$O$为垂心, $\overrightarrow{OA}\cdot\overrightarrow{OB}=\overrightarrow{OB}\cdot\overrightarrow{OC}=\overrightarrow{OC}\cdot\overrightarrow{OA}, \overrightarrow{OB}\cdot\overrightarrow{CA}=\overrightarrow{AO}\cdot\overrightarrow{BC}=\overrightarrow{CO}\cdot\overrightarrow{AB}=0$</p></li><li><p>$O$为内心, $\overrightarrow{OA}\cdot(\frac{\overrightarrow{AC} }{|\overrightarrow{AC}|}-\frac{\overrightarrow{AB} }{|\overrightarrow{AB}|})=\overrightarrow{OB}\cdot(\frac{\overrightarrow{BC} }{|\overrightarrow{BC}|}-\frac{\overrightarrow{BA} }{|\overrightarrow{BA}|})=0, a\overrightarrow{OA}+b\overrightarrow{OB}+c\overrightarrow{OC}=0$</p></li><li><p>$O$为外心, $||\overrightarrow{OA}||=|\overrightarrow{OB}|=|\overrightarrow{OC}|, (\overrightarrow{OA}+\overrightarrow{OB})\cdot\overrightarrow{AB}=\overrightarrow{OB}+\overrightarrow{OC})\cdot\overrightarrow{BC}=\overrightarrow{OA}+\overrightarrow{OC})\cdot\overrightarrow{AC}=0$</p></li></ul><h2 id="6-3-5-平面向量数量积的坐标表示"><a href="#6-3-5-平面向量数量积的坐标表示" class="headerlink" title="6.3.5 平面向量数量积的坐标表示"></a>6.3.5 平面向量数量积的坐标表示</h2><h3 id="1-overrightarrow-a-x-1-y-1-overrightarrow-b-x-2-y-2"><a href="#1-overrightarrow-a-x-1-y-1-overrightarrow-b-x-2-y-2" class="headerlink" title="1. $\overrightarrow{a}=(x_1,y_1),\overrightarrow{b}=(x_2,y_2)$"></a>1. $\overrightarrow{a}=(x_1,y_1),\overrightarrow{b}=(x_2,y_2)$</h3><ul><li>$\overrightarrow{a}\cdot \overrightarrow{b}=|\overrightarrow{a}|\cdot|\overrightarrow{b}|\cos{\theta}=x_1x_2+y_1y_2$</li><li>$\overrightarrow{a}//\overrightarrow{b}\Leftrightarrow\overrightarrow{a}=\lambda\overrightarrow{b}(\overrightarrow{b}\neq\overrightarrow{0})\Leftrightarrow x_1y_2-x_2y_1=0$</li><li>$\overrightarrow{a}\perp \overrightarrow{b}\Leftrightarrow\overrightarrow{a}\cdot \overrightarrow{b}=0\Leftrightarrow x_1x_2+y_1y_2=0$</li><li>$\overrightarrow{a}^2=|\overrightarrow{a}|^2$, $|\overrightarrow{a}|=\sqrt{x_1^2+y_1^2}$</li></ul><h3 id="2-A-x-1-y-1-B-x-2-y-2"><a href="#2-A-x-1-y-1-B-x-2-y-2" class="headerlink" title="2. $A(x_1,y_1),B(x_2,y_2)$"></a>2. $A(x_1,y_1),B(x_2,y_2)$</h3><ul><li>$|\overrightarrow{AB}|=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$</li><li>$\cos\theta=\frac{\overrightarrow{a}\cdot \overrightarrow{b} }{|\overrightarrow{a}|\cdot|\overrightarrow{b}|}=\frac{x_1x_2+y_1y_2}{\sqrt{(x_1-x_2)^2+(y_1-y_2)^2} }$</li></ul><h3 id="3-S-triangle-ABC-frac-1-2-AB-AC-sin-A"><a href="#3-S-triangle-ABC-frac-1-2-AB-AC-sin-A" class="headerlink" title="3. $S_{\triangle ABC}=\frac{1}{2}|AB||AC|\sin A$"></a>3. $S_{\triangle ABC}=\frac{1}{2}|AB||AC|\sin A$</h3><h3 id="题型-5"><a href="#题型-5" class="headerlink" title="题型"></a>题型</h3><ul><li><p>已知$a=(1,-1）, b（\lambda, 1)$, 若$a$与$b$度夹角$\alpha$为钝角, 求$\lambda$取值范围</p></li><li><p>在$\triangle ABC$中, $\overrightarrow{AB}=(2,3),\overrightarrow{AC}=(1,k)$, 若$Rt\triangle ABC$, 求$k$的值</p><p>​ <img data-src="/images/math_12.png" alt="12"></p></li><li><p>已知$\overrightarrow{c}=m\overrightarrow{a}+n\overrightarrow{b},\overrightarrow{c}=(-2\sqrt{3},2) ,\overrightarrow{a}\pm\overrightarrow{c},\overrightarrow{b}$与$\overrightarrow{c}$的夹角为$\frac{2\pi}{3}\overrightarrow{b}\cdot \overrightarrow{c}=-4, |\overrightarrow{a}|=2\sqrt{2}$, 求$m,n$即$\overrightarrow{a}$和$\overrightarrow{b}$的夹角$\theta$</p><p><img data-src="/images/math_13.png" alt="13" style="zoom:50%"></p><p><img data-src="/images/math_14.png" alt="14" style="zoom:50%"></p></li></ul><h2 id="6-4-3-1-余弦定理"><a href="#6-4-3-1-余弦定理" class="headerlink" title="6.4.3.1 余弦定理"></a>6.4.3.1 余弦定理</h2><h3 id="1-公式"><a href="#1-公式" class="headerlink" title="1. 公式"></a>1. 公式</h3><ul><li><p>$a^2=b^2+c^2-2bc\cos A$</p></li><li><p>$b^2=a^2+c^2-2ac\cos B$</p></li><li><p>$c^2=a^2+b^2-2ab\cos C$</p></li><li><p>$\cos A=\frac{b^2+c^2-a^2}{2bc}$</p></li><li><p>$\cos B=\frac{a^2+c^2-b^2}{2ac}$</p></li><li><p>$\cos C=\frac{a^2+b^2-c^2}{2ab}$</p></li><li><p>证明:</p><script type="math/tex;mode=display">\begin{align*}
&(\overrightarrow{CB}-\overrightarrow{CA})=\overrightarrow{AB}^2\\
&\overrightarrow{CB}^2+\overrightarrow{CA}^2-2\overrightarrow{CB}\cdot\overrightarrow{CA}=\overrightarrow{AB}^2\\
\therefore&a^2+b^2-2ab\cos C=c^2\\
\therefore&\cos C=\frac{a^2+b^2-c^2}{2ab}\\
\end{align*}</script></li></ul><h3 id="题型-6"><a href="#题型-6" class="headerlink" title="题型"></a>题型</h3><h4 id="1-解三角形-begin-cases-两边及其夹角-公式-两边及一边对角-end-cases"><a href="#1-解三角形-begin-cases-两边及其夹角-公式-两边及一边对角-end-cases" class="headerlink" title="1. 解三角形$\begin{cases}两边及其夹角(公式)\\两边及一边对角\end{cases}$"></a>1. 解三角形$\begin{cases}两边及其夹角(公式)\\两边及一边对角\end{cases}$</h4><ul><li><p>e.g.</p><ul><li><p>在$\triangle ABC$中, $b=3,c=2\sqrt{3},A=30^\circ$,求$a=\sqrt{3}$</p></li><li><p>在$\triangle ABC$中, $A=120^\circ, a=7,b+c=8$, 求$b,c$<br>$bc=15,b+c=8$</p></li><li><p>在$\triangle ABC$中, $a^2=b^2-c^2+\sqrt{2}ac$, 则$B=$</p></li></ul></li></ul><h4 id="2-判断三角形形状-边角互换"><a href="#2-判断三角形形状-边角互换" class="headerlink" title="2. 判断三角形形状: 边角互换"></a>2. 判断三角形形状: 边角互换</h4><ul><li><p>e.g.</p><ul><li>在$\triangle ABC$中, $b(a-c\cos B)=a(b-c\cos A)$, 求$\triangle ABC$形状</li></ul></li></ul><script type="math/tex;mode=display">\begin{align*}
    &ab-bc\cos B=ab-ac\cos A\\
    &\frac{a^2+c^2-b^2}{2ac}b=\frac{b^2+c^2-a^2}{2bc}a\\
    &b^2(a^2+c^2-b^2)=a^2(b^2+c^2-a^2)\\
    &b^2c^2-a^2c^2=b^4-a^4\\
    &c^2(b^2-a^2)-(a^2+b^2)(b^2-a^2) =0\\
    &(c^2-a^2-b^2)(b^2-a^2) =0\\
    \therefore&\text{等腰或直角}
  \end{align*}</script><ul><li>$\triangle ABC$中, $\cos^2 \frac{A}{2}=\frac{b+c}{2}$, 判断三角形形状</li></ul><h4 id="3-求值问题"><a href="#3-求值问题" class="headerlink" title="3. 求值问题"></a>3. 求值问题</h4><ul><li><p>e.g.</p><ul><li><p>$\triangle ABC$中</p><p>(1). $2b\cos C-2a+c=0$, 求$B$</p><p>(2). $a+c=5, ac=4\sqrt{2}, \tan B=1$, 求$b^2$</p></li></ul></li></ul><h2 id="6-4-3-2-正弦定理"><a href="#6-4-3-2-正弦定理" class="headerlink" title="6.4.3.2 正弦定理"></a>6.4.3.2 正弦定理</h2><h3 id="1-公式-1"><a href="#1-公式-1" class="headerlink" title="1. 公式"></a>1. 公式</h3><ul><li><p>$\frac{a}{\sin A}=\frac{b}{\sin B}=\frac{c}{\sin C}=2R(\triangle ABC的外接圆半径)$</p></li><li><p>$\frac{a+b+c}{\sin A+\sin B+\sin C}=\frac{a}{\sin A}=\frac{b}{\sin B}=\frac{c}{\sin C}$</p></li><li><p>$\triangle ABC$中, 大边对大角, 小边对小角</p></li><li><p>$S_{\triangle ABC}=\frac{1}{2}ab\sin C=\frac{1}{2}bc\sin A=\frac{1}{2}ac\sin B=\frac{abc}{4R(外接圆半径)}=\frac{r(内切圆半径)}{2}(a+b+c)$</p></li></ul><h3 id="题型-7"><a href="#题型-7" class="headerlink" title="题型"></a>题型</h3><h4 id="1-解三角形-begin-cases-两角一边-两边及一边对角-end-cases"><a href="#1-解三角形-begin-cases-两角一边-两边及一边对角-end-cases" class="headerlink" title="1. 解三角形$\begin{cases}两角一边\\两边及一边对角\\\end{cases}$"></a>1. 解三角形$\begin{cases}两角一边\\两边及一边对角\\\end{cases}$</h4><ul><li><p>e.g.</p><ul><li><p>$a=\sqrt{3},b=\sqrt{2},B=45^\circ$</p></li><li><p>$A=60^\circ, c=\sqrt{2},a=\sqrt{6}$</p></li></ul></li></ul><h4 id="2-判断三角形形状"><a href="#2-判断三角形形状" class="headerlink" title="2. 判断三角形形状"></a>2. 判断三角形形状</h4><ul><li><p>e.g.</p><ul><li>$\triangle ABC$中, $b=\cos A$, 判断$\triangle ABC$形状</li></ul></li></ul><h4 id="3-作业整理"><a href="#3-作业整理" class="headerlink" title="3. 作业整理"></a>3. 作业整理</h4><ul><li>$a=x(x&gt;0),b=2,B=45^\circ$, $\triangle ABC$有两个解和一个解时, 求$x$范围</li></ul><script type="math/tex;mode=display">\begin{align*}
        &&\sin A=\frac{x}{b}\sin B\\
        两解:&\sin B<\sin A<1 & 一解:&0<\sin A<\sin B或\sin A=1\\
        &\frac{\sqrt{2} }{2}<\frac{x}{2}\cdot \frac{\sqrt{2} }{2}<1&&0<\frac{x}{2}\cdot\frac{\sqrt{2} }{2}\leq\frac{\sqrt{2} }{2}或\frac{x}{2}\cdot\frac{\sqrt{2} }{2}=1\\
        &2<x<2\sqrt{2}&&x=2\sqrt{2}\\
\end{align*}</script><ul><li>锐角$\triangle ABC$中, $B=2A$, 则$\frac{b}{a}$范围是</li></ul><script type="math/tex;mode=display">\begin{align*}
        &\frac{b}{a}=\frac{\sin B}{\sin A}=\frac{2\sin A\cos A}{\sin A}=2\cos A\\
        &\begin{cases}
            A<\frac{\pi}{2}\\
            B=2\cdot A<\frac{\pi}{2}\\
            C=\pi -A-B=\pi -3A<\frac{\pi}{2}\\
        \end{cases}\\
        \therefore& \frac{\pi}{6}<A<\frac{\pi}{4}\\
        \therefore& \frac{b}{a}\in(\sqrt{2},\sqrt{3})\\
\end{align*}</script><ul><li>$\triangle ABC$中, $\sin 2A=\sin 2B$, 判断$\triangle ABC$形状</li></ul><script type="math/tex;mode=display">\begin{align*}
        &2A=2B+2k\pi或2A=\pi-2B+2k\pi\\
        \therefore&A=B+k\pi或A=\frac{\pi}{2}-B+k\pi\\
        又\because&A,B\in(0,\pi)\\
        \therefore&A=B或A=\frac{\pi}{2}-B\\
        \therefore&等腰或直角\\
\end{align*}</script><ul><li>$\triangle ABC$中, $\frac{\sin A}{a}=\frac{\cos B}{b}=\frac{\cos C}{c}$, 判断三角形形状。</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>边角互化: 优先正弦定理</p></li><li><p>余弦定理: $a+b,ab,a^2+b^2$间关系($a^2+b^2=(a+b)^2-2ab$)</p></li><li><p>正弦定理:</p><ul><li><p>和差公式</p></li><li><p>辅助角公式</p></li><li><p>替换思想($B=\frac{\pi}{3}\Rightarrow A+C=\frac{2\pi}{3}$)</p></li></ul></li><li><p>互补、互余角的正余弦关系</p></li></ul><h2 id="整理-1"><a href="#整理-1" class="headerlink" title="整理"></a>整理</h2><ul><li>如图,一直线$EF$与平行四边形$ABCD$的两边$AB,AD$分别交于$E,F$两点,且交对角线$AC$于点$K$,其中,$\overrightarrow{AE}=\frac{2}{5}\overrightarrow{AB},\overrightarrow{AF}=\frac{1}{2}\overrightarrow{AD},\overrightarrow{AK}=\lambda\overrightarrow{AC}$, 则$\lambda$的值为</li></ul><p><img data-src="/images/math_15.png" alt="15"></p><script type="math/tex;mode=display">\begin{align*}
&法一:&\overrightarrow{AK}&=\lambda \overrightarrow{AC}&法二: &做FG//AB\\
&&&=\lambda(\overrightarrow{AB}+\overrightarrow{AD})&\therefore&FG=\frac{1}{2}\overrightarrow{AB} \\
&&&=\lambda(\frac{5}{2}\overrightarrow{AE}+2\overrightarrow{AD})&\therefore&\overrightarrow{AK}=\frac{4}{9}\overrightarrow{AG}=\frac{2}{9}\overrightarrow{AC}\\
&&&=\frac{5\lambda}{2}\overrightarrow{AE}+2\lambda\overrightarrow{AF}&\therefore&\lambda=\frac{2}{9}\\
&&&\because共线\ \therefore\frac{5\lambda}{2}+2\lambda=1&\\
\end{align*}</script><ul><li>已知平面向量$\overrightarrow{AB},\overrightarrow{AC}$的模都为$2$, $\overrightarrow{AB},\overrightarrow{AC}$夹角$90^\circ$, 若$\overrightarrow{BM}=\lambda\overrightarrow{MC}(\lambda\ne0)$,则$\overrightarrow{AM}\cdot(\overrightarrow{AB}+\overrightarrow{AC})$的值为</li></ul><script type="math/tex;mode=display">\begin{align*}
法一:&\overrightarrow{AM}\cdot(\overrightarrow{AB}+\overrightarrow{AC})&法二:&设BC:y=-x+2\\
&=\frac{1}{1+\lambda}(\overrightarrow{AB}+\lambda \overrightarrow{AC})(\overrightarrow{AB}+\overrightarrow{AC})&\therefore&\overrightarrow{AM}=(x,-x+2)\\
&=\frac{1}{1+\lambda}(\overrightarrow{AB}^2+\lambda\overrightarrow{AC}^2)&\therefore&\overrightarrow{AM}\cdot(\overrightarrow{AB}+\overrightarrow{AC})\\
&=\frac{1}{1+\lambda}(4+4\lambda)=4&=&(x,-x+2)\cdot(2,2)=4\\
\end{align*}</script><ul><li><p>在$\triangle ABC$中, $AOB$为直角$\overrightarrow{OC}=\frac{1}{4}\overrightarrow{OA}, \overrightarrow{OD}=\frac{1}{2}\overrightarrow{OB},AD$与$BC$相交于点$M$, $\overrightarrow{OA}=\overrightarrow{a},\overrightarrow{OB}=\overrightarrow{b}$</p><ul><li><p>用$\overrightarrow{a},\overrightarrow{b}$表示$\overrightarrow{OM}$</p></li><li><p>在线段$AC$上取一点$E$, 在线段$BD$上取一点$F$, 使得直线$EF$过$M$,设$\overrightarrow{OE}=\lambda\overrightarrow{OA},\overrightarrow{OF}=\mu\overrightarrow{OB}$, 求$\frac{1}{\lambda}+\frac{3}{\mu}$的值</p><script type="math/tex;mode=display">\begin{align*}
&\overrightarrow{OM}=\frac{1}{7}\overrightarrow{OA}+\frac{3}{7}\overrightarrow{OB}&\\
&=\frac{1}{7}\cdot \frac{1}{\lambda}\overrightarrow{OE}+\frac{3}{7}\cdot \frac{1}{\mu}\overrightarrow{OF}&\\
&\because M,E,F共线&\\
&\therefore \frac{1}{7\lambda}+\frac{3}{7\mu}=1&\\
\end{align*}</script></li><li><p>若$|AB|=a$, 过$O$作线段$PQ$, 使得$O$为$PQ$的中点, 且$|PQ|=2a$, 求$\overrightarrow{AP}\cdot\overrightarrow{BQ}$的取值范围</p></li></ul><script type="math/tex;mode=display">\begin{align*}
\overrightarrow{AP}\cdot\overrightarrow{BQ}&=(\overrightarrow{OP}-\overrightarrow{OA})\cdot(\overrightarrow{OQ}-\overrightarrow{OB})\\
&=\overrightarrow{OP}\cdot\overrightarrow{OQ}-\overrightarrow{OP}\cdot\overrightarrow{OB}-\overrightarrow{OA}\cdot\overrightarrow{OQ}\\
&=-a^2-\overrightarrow{OP}\cdot\overrightarrow{OB}+\overrightarrow{OA}\cdot\overrightarrow{OP}\\
&=-a^2-\overrightarrow{OP}\cdot(\overrightarrow{OA}-\overrightarrow{OB})\\
&=-a^2+\overrightarrow{OP}\cdot\overrightarrow{BA}\\
&=-a^2+|\overrightarrow{OP}|\cdot|\overrightarrow{BQ}|\cos\theta\\
&=-a^2+a^2\cos\theta\\
&=a^2(\cos\theta-1)\\
&\because-1\le\cos\theta\le1\\
&\therefore-2\le\cos\theta\le0\\
&\therefore\overrightarrow{AP}\cdot\overrightarrow{BQ}\in[-2a,0]
\end{align*}</script></li><li><p>$O$为$\triangle ABC$的外心, $AB=4,AC=2,\angle BAC$为钝角,$M$是边$BC$的中点, 则$\overrightarrow{AM}\cdot\overrightarrow{AO}$等于</p><p><img data-src="/images/math_16.png" alt="16"></p><script type="math/tex;mode=display">\begin{align*}
\overrightarrow{AM}\cdot\overrightarrow{AO}&=\frac{1}{2}(\overrightarrow{AB}+\overrightarrow{AC})\cdot\overrightarrow{AO}\\
&=\frac{1}{2}\overrightarrow{AB}\cdot(\overrightarrow{AD}+\overrightarrow{OD})+\frac{1}{2}\overrightarrow{AC}\cdot(\overrightarrow{AE}+\overrightarrow{EO})\\
&=\frac{1}{2}\overrightarrow{AB}\cdot\overrightarrow{AD}+\frac{1}{2}\overrightarrow{AC}\cdot\overrightarrow{AE}\\
&=\frac{1}{4}\overrightarrow{AB}^2+\frac{1}{4}\overrightarrow{AC}\\
&=\frac{1}{4}\cdot16+\frac{1}{4}\cdot4\\
&=5\\
\end{align*}</script></li><li><p>已知向量$\overrightarrow{a}=(1,1),\overrightarrow{b}=(1,-1),\overrightarrow{c}=(\sqrt{2}\cos\alpha,\sqrt{2}\sin\alpha)(a\in\mathbb{R})$,实数$m,n$满足$m\overrightarrow{a}+n\overrightarrow{b}=\overrightarrow{c}$, 则$(m-3)^2+n^2$的最大值为</p><script type="math/tex;mode=display">\begin{align*}
&&\begin{cases}m+n=\sqrt{2}\cos\alpha\\m-n=\sqrt{2}\sin\alpha\\\end{cases}\\
法一:&\therefore m^2+n^2=1\Rightarrow n^2=1-m^2\ge0\Rightarrow-1\le m\le1&法二:&\begin{cases}m=\sin(\alpha+\frac{\pi}{4})\\n=\cos(\alpha+\frac{\pi}{4})\\\end{cases}\\
&\therefore(m-3)^2+n^2=(m-3)^2+1-m^2&\therefore&(m-3)^2+n^2=m^2+n^2-6m+9\\
&=-6m+10\in[4,16]&&=1+9-6m\\
&&&=10-6\sin(\alpha+\frac{\pi}{4})\\
&&&\because\sin(\alpha+\frac{\pi}{4})\in[-1,1]
&&&\therefore\text{最大值}为16\\
\end{align*}</script><p>或<img data-src="/images/math_17.png" alt="17"></p></li><li><p>在$\triangle ABC$中, 角$A,B,C$所对的边分别为$a,b,c$. 若$\triangle ABC$为锐角三角形, 且满足$b^2-a^2=ac$, 则$\frac{1}{\tan{A} }-\frac{1}{\tan{B} }$的取值范围是</p></li></ul><script type="math/tex;mode=display">\begin{align*}
&b^2-a^2=ac\\
&b^2=a^2+ac\\
&又\because b^2=a^2+c^2-2ac\cos{B}\\
&a=c-2a\cos{B}\\
&\sin{A}=\sin{C}-2\sin{A}\cos{B}\\
&=\sin{A+B}-2\sin{A}\cos{B}\\
&=\cos{A}\sin{B}-\sin{A}\cos{B}\\
&=\sin{B-A}\\
&\therefore 原式=\frac{\sin{A} }{\sin{A}\sin{B} }=\frac{1}{\sin{B} }\\
&\begin{cases}0<B<\frac{\pi}{2}\\0<A=\frac{B}{2}<\frac{\pi}{2}\\0<C=\pi-\frac{3B}{2}<\frac{\pi}{2}\\\end{cases}\Rightarrow\frac{\pi}{3}<B<\frac{\pi}{2}\\
&\therefore \frac{\sqrt{3} }{3}<\sin{B}<1\\
&\therefore \frac{1}{\tan{A} }-\frac{1}{\tan{B} }\in(1,\frac{2\sqrt{3} }{3})
\end{align*}</script><ul><li>在$\triangle ABC$中, $AB=AC=3, \angle BAC=90^\circ, D$为$BC$中点, $M$在$\triangle ACD$内部(不含边界), $\overrightarrow{AM}=\frac{1}{3}\overrightarrow{AB}+m\overrightarrow{AC}$, 则$\overrightarrow{DM}+\overrightarrow{BM}$取值范围是</li></ul><p><img data-src="/images/math_18.png" alt="18"></p><script type="math/tex;mode=display">\begin{align*}
\overrightarrow{AM}=\frac{1}{3}\overrightarrow{AB}+m\overrightarrow{AC}=\frac{1}{3}(3,0)+m(0,3)\\
\therefore\overrightarrow{DM}\cdot\overrightarrow{BM}=(1-\frac{3}{2},3m-\frac{3}{2})\cdot(1-3,3m-0)\\
=1+9(m^2-\frac{1}{2}m)\\
\because M在\triangle ACD内部\\
\therefore m\in(\frac{1}{3},\frac{2}{3})\\
\therefore\overrightarrow{DM}\cdot\overrightarrow{BM}\in(\frac{1}{2},2)\\
\end{align*}</script><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="7-1-数系的扩充和复数的概念"><a href="#7-1-数系的扩充和复数的概念" class="headerlink" title="7.1 数系的扩充和复数的概念"></a>7.1 数系的扩充和复数的概念</h2><h3 id="1-复数"><a href="#1-复数" class="headerlink" title="1. 复数:"></a>1. 复数:</h3><ul><li><p>形如$a+bi(a,b\in\mathbb{R})$</p></li><li><p>$a$为实部, $b$为虚部, $i$为虚数单位$(i^2=-1)$</p></li><li><p>复数集$\mathbb{C}={a+bi, a,b\in \mathbb{R} }$</p></li></ul><h3 id="2-两个复数相等的充要条件-a-1-a-2-b-1-b-2"><a href="#2-两个复数相等的充要条件-a-1-a-2-b-1-b-2" class="headerlink" title="2. 两个复数相等的充要条件: $a_1=a_2, b_1=b_2$"></a>2. 两个复数相等的充要条件: $a_1=a_2, b_1=b_2$</h3><h3 id="3-复数的分类"><a href="#3-复数的分类" class="headerlink" title="3. 复数的分类"></a>3. 复数的分类</h3><ul><li>$z=a+bi(a,b\in \mathbb{R})\begin{cases}b=0&amp;实数\\b\neq0&amp;虚数\begin{cases}a=0&amp;纯虚数\\a\neq0&amp;非纯虚数\\\end{cases}\\\end{cases}$</li></ul><h3 id="题型-8"><a href="#题型-8" class="headerlink" title="题型"></a>题型</h3><h4 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h4><ul><li><p>复数$z=a+bi&gt;0$, 则$a&gt;0,b=0$</p></li><li><p>$a+bi&gt;c+di$, 则$\begin{cases}b=d=0\\a&gt;c\\\end{cases}$</p></li></ul><h2 id="7-1-2-复数的加、减运算及其几何意义"><a href="#7-1-2-复数的加、减运算及其几何意义" class="headerlink" title="7.1.2 复数的加、减运算及其几何意义"></a>7.1.2 复数的加、减运算及其几何意义</h2><h3 id="1-复平面"><a href="#1-复平面" class="headerlink" title="1. 复平面"></a>1. 复平面</h3><ul><li><img data-src="/images/math_19.png" alt="19"></li></ul><h3 id="2-复数的几何意义"><a href="#2-复数的几何意义" class="headerlink" title="2. 复数的几何意义"></a>2. 复数的几何意义</h3><ul><li><img data-src="/images/math_20.png" alt="20"></li></ul><h3 id="3-复数的模"><a href="#3-复数的模" class="headerlink" title="3. 复数的模"></a>3. 复数的模</h3><ul><li><p>定义: $\overrightarrow{OZ}$的模叫做复数$z=a+bi$的模</p></li><li><p>记法: 复数$z=a+bi$的模记为$|z|$或$|a+bi|$且$|z|=\sqrt{a^2+b^2}$</p></li><li><p>复数$z$满足$|z-i|=1$, 其几何意义是: 点$z$到点$(0,1)$的距离为$1$</p></li></ul><h3 id="4-共轭复数"><a href="#4-共轭复数" class="headerlink" title="4. 共轭复数"></a>4. 共轭复数</h3><ul><li><p>当两个复数的实部相等, 虚部<strong>互为相反数</strong>时, 这两个复数叫做互为共轭复数.</p></li><li><p>复数$z$的共轭复数用$\overline{z}$表示, 即如果$z=a+bi$,那么$\overline{z}=a-bi$.</p></li></ul><h3 id="题型-9"><a href="#题型-9" class="headerlink" title="题型"></a>题型</h3><h4 id="1-几何意义的应用"><a href="#1-几何意义的应用" class="headerlink" title="1. 几何意义的应用"></a>1. 几何意义的应用</h4><ul><li><p>复数$z$满足$|z-i|=1$, 其几何意义是: 点$z$到点$(0,1)$的距离为$1$</p></li><li><p>$|z+1+i|=1$, 其几何意义是: 以$(0,1)$为圆心,半径为$1$的圆</p></li><li><p>$|z-1|=|z+2i|$, 其几何意义是: $(1,0)$和$(0.-2)$点所连线的垂直平分线</p></li></ul><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="8-1-基本立体图形"><a href="#8-1-基本立体图形" class="headerlink" title="8.1 基本立体图形"></a>8.1 基本立体图形</h2><h3 id="1-棱柱"><a href="#1-棱柱" class="headerlink" title="1. 棱柱"></a>1. 棱柱</h3><ul><li><p>有两个面互相<strong>平行</strong>, 其余各面都是<strong>四边形</strong>, 并且相邻两个四边形的公共边都互相<strong>平行</strong></p></li><li><p>特殊情形$\begin{cases}直棱柱&amp;侧棱垂直于底面的棱柱\\斜棱柱&amp;侧棱不垂直于底面的棱柱\\正棱柱&amp;底面是正多边形的直棱柱\\\end{cases}$</p></li><li><p>记法: 棱柱$ABC-A_1B_1C_1$</p></li><li><p>上下两面平行, 侧面都是平行四边形的多面体是棱柱? $\times$ 反例: <img data-src="/images/math_21.png" alt="21"></p></li></ul><h3 id="2-棱锥"><a href="#2-棱锥" class="headerlink" title="2. 棱锥"></a>2. 棱锥</h3><ul><li><p>一个面是<strong>多边形</strong>余各面都是有一个共顶点的<strong>三角形</strong>这些面所围成的多面体</p></li><li><p>正棱锥: 底面是正多边形, 并且顶点与底面中心的连线垂直于底面的棱锥</p></li><li><p>记作: 棱锥$S-ABC$</p></li><li><p>一个面是多边形余各面都是三角形这些面所围成的多面体是棱柱? $\times$ 反例: <img data-src="/images/math_22.png" alt="22" style="zoom:33%"></p></li></ul><h3 id="3-棱台"><a href="#3-棱台" class="headerlink" title="3. 棱台"></a>3. 棱台</h3><ul><li><p>用一个<strong>平行于棱锥底面</strong>的平面去截棱锥, 底面和截面之间那部分多面体</p></li><li><p>记法: 棱台$ABC-A_1B_1C_1$</p></li><li><p>两个平面相互平行, 侧面是梯形的多面体是棱台? $\times$(可能延长之后不交与一点)</p></li><li><p>两个平面相互平行且相似, 侧面是梯形的多面体是棱台? $\times$(上下底面可能扭转)</p></li></ul><h3 id="4-圆柱"><a href="#4-圆柱" class="headerlink" title="4. 圆柱"></a>4. 圆柱</h3><ul><li><p>以<strong>矩形的一边所在直线</strong>为旋转轴</p></li><li><p><img data-src="/images/math_24.png" alt="24"></p></li><li><p>记法: 圆柱$O’-O$</p></li></ul><h3 id="5-圆锥"><a href="#5-圆锥" class="headerlink" title="5. 圆锥"></a>5. 圆锥</h3><ul><li><p>以<strong>直角三角形的一条直角边</strong>所在直线为旋传轴</p></li><li><p><img data-src="/images/math_25.png" alt="25"></p></li><li><p>记法: 圆锥$SO$</p></li></ul><h3 id="6-圆台"><a href="#6-圆台" class="headerlink" title="6. 圆台"></a>6. 圆台</h3><ul><li>用平行于<strong>圆锥底面</strong>的平面去截圆锥, 底面与截面之间的部分</li></ul><h3 id="7-球"><a href="#7-球" class="headerlink" title="7. 球"></a>7. 球</h3><ul><li><p>半圆以它的<strong>直径所在直线</strong>为旋转轴, 旋转一周形成的曲面</p></li><li><p><img data-src="/images/math_26.png" alt="26"></p></li><li><p>记法: 球$O$</p></li></ul><h3 id="题型-10"><a href="#题型-10" class="headerlink" title="题型"></a>题型</h3><ul><li>长方体$ABCD- A_1B_1C_1D_1$中, $AB=4, BC=3, BB_1=5$, 一只蚂蚁从点$A$出发沿表面爬行到点$C$,求蚂蚁爬行的最短路线长</li></ul><p><img data-src="/images/math_23.png" alt="23"></p><h2 id="8-2-立体图形的直观图"><a href="#8-2-立体图形的直观图" class="headerlink" title="8.2 立体图形的直观图"></a>8.2 立体图形的直观图</h2><h3 id="1-斜二测画法"><a href="#1-斜二测画法" class="headerlink" title="1. 斜二测画法"></a>1. 斜二测画法</h3><ul><li><p>画轴:</p><ul><li>在已知图形中取互相垂直的$x$轴和$y$轴,两轴相交于点$O$. 画直观图时, 把它们画成对应的$x’$轴与$y’$轴,两轴相交于点$O’$,且使$\angle x’O’y’=45^\circ(或135^\circ)$,它们确定的平面表示水平面</li><li>建系位置关键</li></ul></li><li><p>确定点</p></li><li><p>连结点</p></li><li><p>作出图形</p></li><li><p>$S_{平面图}=2\sqrt{2}S_{直观图}, S_{直观图}=\frac{\sqrt{2} }{4}S_{平面图}$</p></li></ul><h3 id="2-各种公式"><a href="#2-各种公式" class="headerlink" title="2. 各种公式"></a>2. 各种公式</h3><ul><li><p>$V_{棱柱}=Sh$</p></li><li><p>$V_{棱锥}=\frac{1}{3}Sh$</p></li><li><p>$V_{棱台}=\frac{1}{3}(S’+\sqrt{S’s}+s)h$</p></li><li><p>$S_{圆柱}=2\pi rl+2\pi r^2=2\pi r(l+r)$</p></li><li><p>$S_{圆锥}=\pi rl+\pi r^2=\pi r(l+r)$</p></li><li><p>$S_{圆台}=\pi rl+\pi Rl+\pi r^2+\pi R^2=\pi(r^2+rl+R^2+Rl)$</p></li><li><p>$V_{圆柱}=\pi r^2h$</p></li><li><p>$V_{圆锥}=\frac{1}{3}\pi r^2h$</p></li><li><p>$V_{圆台}=\frac{1}{3}\pi(r^2+Rr+R^2)h$</p></li><li><p>$S_{球}=4\pi r^2$</p></li><li><p>$V_{球}=\frac{4}{3}\pi r^3$</p></li></ul><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul><li><p>平面四边形 四边形</p></li><li><p>平行四边形对角线的平方和等于四边的平方和</p></li><li><p>空间四边形 四面体</p></li></ul><h3 id="4-求体积"><a href="#4-求体积" class="headerlink" title="4. 求体积"></a>4. 求体积</h3><ul><li><p>公式法</p></li><li><p>等体积法(换底, 换顶点)</p></li><li><p>分割法</p></li><li><p>补形法</p></li></ul><h3 id="5-外接问题"><a href="#5-外接问题" class="headerlink" title="5. 外接问题"></a>5. 外接问题</h3><ul><li><p>正方体边长为$a\begin{cases}与面相切&amp;2R=a\\与棱相切&amp;2R=\sqrt{2}a\\与顶相切&amp;2R=\sqrt{3}a\\\end{cases}$</p></li><li><p>长方体外接球 $2R=\sqrt{a^2+b^2+c^2}$</p></li><li><p>$\begin{cases}多面体外接球&amp;关键是球心\\多面体内切球&amp;可用体积球半径\\\end{cases}$</p></li><li><p>正四面体外接圆, $R=\frac{\sqrt{6} }{4}a$</p></li></ul><h3 id="6-内接问题"><a href="#6-内接问题" class="headerlink" title="6. 内接问题"></a>6. 内接问题</h3><ul><li>正四面体内接圆, $R=\frac{\sqrt{6} }{12}a$</li></ul><h2 id="8-3-平面"><a href="#8-3-平面" class="headerlink" title="8.3 平面"></a>8.3 平面</h2><h3 id="1-平面的画法"><a href="#1-平面的画法" class="headerlink" title="1. 平面的画法"></a>1. 平面的画法</h3><ul><li><p>常用平行四边形表示</p></li><li><p><img data-src="/images/math_27.png" alt="27"></p></li><li><p>记为平面$\alpha$, 平面$ABCD$或平面$AC$</p></li></ul><h3 id="2-符号表示"><a href="#2-符号表示" class="headerlink" title="2. 符号表示"></a>2. 符号表示</h3><ul><li><p>点$A$在直线$l$上 $A\in l$</p></li><li><p>点$A$在直线$l$外 $A\notin l$</p></li><li><p>点$A$在平面$\alpha$内 $A\in a$</p></li><li><p>点$A$在平面$\alpha$外 $A\notin a$</p></li><li><p>直线$l$在平面$\alpha$内 $I\subset a$</p></li><li><p>直线$l$在平面$\alpha$外 $l⊄a$</p></li><li><p>平面$\alpha,\beta$相交于$l$ $\alpha\cap\beta=l$</p></li><li><p><img data-src="/images/math_28.png" alt="28"></p></li></ul><h2 id="8-4-空间点、直线、平面之间的位置关系"><a href="#8-4-空间点、直线、平面之间的位置关系" class="headerlink" title="8.4 空间点、直线、平面之间的位置关系"></a>8.4 空间点、直线、平面之间的位置关系</h2><h3 id="1-基本事实"><a href="#1-基本事实" class="headerlink" title="1. 基本事实"></a>1. 基本事实</h3><h4 id="1-基本事实一"><a href="#1-基本事实一" class="headerlink" title="1. 基本事实一"></a>1. 基本事实一</h4><ul><li><p>过<strong>不在条直线</strong>上的三个点, 有且只有一个平面</p></li><li><p>图像: <img data-src="/images/math_29.png" alt="29"></p></li><li><p>符号: $A,B,C$三点不共线$\Rightarrow$存在唯一的$\alpha$使$A,B,C\in\alpha$</p></li><li><p>推论:</p><ul><li>过不在条直线上的三个点, 有且只有一个平面<img data-src="/images/math_30.png" alt="30"></li><li>经过两条相交直线, 有且只有一个平面<img data-src="/images/math_31.png" alt="31"></li><li>经过两条平行直线, 有且只有一个平面<img data-src="/images/math_32.png" alt="32"></li></ul></li></ul><h4 id="2-基本事实二"><a href="#2-基本事实二" class="headerlink" title="2. 基本事实二"></a>2. 基本事实二</h4><ul><li><p>如果一条直线上的<strong>两个点</strong>一个平面内, 那么这条直线在这个平面内</p></li><li><p>图像: <img data-src="/images/math_33.png" alt="33"></p></li><li><p>符号: $A\in l,B\in l$,且$A\in a,B\in a\Rightarrow l\subset a$</p></li></ul><h4 id="3-基本事实三"><a href="#3-基本事实三" class="headerlink" title="3. 基本事实三"></a>3. 基本事实三</h4><ul><li><p>如果两个不重合的平面有一个公共点, 那么它们有且只有一条<strong>过该点的公共直线</strong></p></li><li><p>图像: <img data-src="/images/math_34.png" alt="34"></p></li><li><p>符号: $P\in\alpha$, 且$P\in\beta\Rightarrow\alpha\cup\beta=l$, 且$P\in l$</p></li></ul><h3 id="2-异面直线"><a href="#2-异面直线" class="headerlink" title="2. 异面直线"></a>2. 异面直线</h3><ul><li><p>定义: <strong>不同在任何一个平面内</strong>的两条直线叫做异面直线</p></li><li><p><img data-src="/images/math_35.png" alt="35"></p></li><li><p>关系 $\begin{cases}共面\begin{cases}相交\\平行\end{cases}\\异面\end{cases}$ 相交1个交点, 其余无交点</p></li></ul><h3 id="3-直线与平面关系"><a href="#3-直线与平面关系" class="headerlink" title="3. 直线与平面关系"></a>3. 直线与平面关系</h3><ul><li>$\begin{cases}直线在平面内\\直线不在平面内\begin{cases}\textbf{相交}&amp;a\cap\alpha=A\\平行&amp;a//\alpha\end{cases}\\\end{cases}$</li></ul><h3 id="4-平面与平面的关系"><a href="#4-平面与平面的关系" class="headerlink" title="4. 平面与平面的关系"></a>4. 平面与平面的关系</h3><ul><li>$\begin{cases}平面平行&amp;\alpha//\beta\\平面相交&amp;\alpha\cap\beta=l\\\end{cases}$</li></ul><h3 id="整理-2"><a href="#整理-2" class="headerlink" title="整理"></a>整理</h3><h4 id="1-体积相等求距离"><a href="#1-体积相等求距离" class="headerlink" title="1. 体积相等求距离"></a>1. 体积相等求距离</h4><ul><li>如图, 在棱长为$a$的正方体$ABCD-A_1B_1C_1D_1$中,求点$A$到平面$A_1BD$的距离$d$ <img data-src="/images/math_36.png" alt="36"></li></ul><h4 id="2-2"><a href="#2-2" class="headerlink" title="2."></a>2.</h4><ul><li>$5$个点, $4$个在同一平面内, 能构成<u>7</u>个平面</li></ul><h2 id="8-5-空间直线、平面的平行"><a href="#8-5-空间直线、平面的平行" class="headerlink" title="8.5 空间直线、平面的平行"></a>8.5 空间直线、平面的平行</h2><h3 id="1-基本事实4"><a href="#1-基本事实4" class="headerlink" title="1. 基本事实4"></a>1. 基本事实4</h3><ul><li><p>文字表述:平行于同一条直线的两条直线<strong>平行</strong>. 这一性质叫做空间平行线的<strong>传递性</strong></p></li><li><p>$a//b,b//a\Rightarrow a//c$</p></li></ul><h3 id="2-等角定理"><a href="#2-等角定理" class="headerlink" title="2. 等角定理"></a>2. 等角定理</h3><ul><li>如果空间中两个角的两条边分别<strong>对应平行</strong>, 那么这两个角<strong>相等或互补</strong></li></ul><h3 id="3-线面平行判定"><a href="#3-线面平行判定" class="headerlink" title="3. 线面平行判定"></a>3. 线面平行判定</h3><ul><li><p>如果平面外一点与此平面一条直线平行, 则直线与此平面平行</p></li><li><p>$l⊄\alpha,m\subset\alpha,l//m\Rightarrow l//\alpha$</p></li></ul><h3 id="4-线面平行性质"><a href="#4-线面平行性质" class="headerlink" title="4. 线面平行性质"></a>4. 线面平行性质</h3><ul><li><p>一条直线与一个平面<strong>平行</strong>, 如果过该直线的平面与此平面<strong>相交</strong>, 则该直线与<strong>交线</strong>平行</p></li><li><p>$l//\alpha, l\subset\beta, \alpha\cap\beta=m\Rightarrow l//m$</p></li></ul><h3 id="5-面面平行判定"><a href="#5-面面平行判定" class="headerlink" title="5. 面面平行判定"></a>5. 面面平行判定</h3><ul><li><p>如果一个平面内的两条<strong>相交</strong>直线与另一个平面平行, 那么这两个平面平行</p></li><li><p>$\begin{cases}a\subset\beta\\b\subset\beta\\a\cap b=P\\a//\alpha\\b//\alpha\end{cases}\Rightarrow\beta//\alpha$</p></li><li><p><img data-src="/images/math_37.png" alt="37" style="zoom:50%"></p></li></ul><h3 id="6-面面平行性质"><a href="#6-面面平行性质" class="headerlink" title="6. 面面平行性质"></a>6. 面面平行性质</h3><ul><li><p>两个平面平行, 如果另一个平面与这两个平面相交, 那么两条交线<strong>平行</strong></p></li><li><p>$\begin{cases}\alpha//\beta\\\alpha\cap\beta=a\\\beta\cap\gamma=b\end{cases}\Rightarrow a//b$</p></li><li><p><img data-src="/images/math_38.png" alt="38" style="zoom:67%"></p></li></ul><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul><li><p>在四棱锥$P-ABCD$中,底面$ABCD$为平行四边形.点$M,N,Q$分别在$PA,BD,PD$上, 且$PM:MA=BN:ND=PQ:QD$ 求证:平面$MNQ//$平面$PBC$<br><img data-src="/images/math_39.png" alt="39" style="zoom:33%"></p><script type="math/tex;mode=display">\begin{align*}
&\triangle ADP中, \frac{PQ}{QD}=\frac{PM}{PA}\therefore MQ//AD\\
&又四边形ABCD为平行四边形\\
\therefore &AD//BC\\
\therefore &MQ//BC\\
\because  &\begin{cases}
  MQ//BC\\
  MQ⊄平面PBC\\
  BC\subset 平面PBC\\
\end{cases}\therefore MQ//平面PBC\\
&\triangle PBD中, \frac{PQ}{QD}=\frac{PB}{ND}\therefore PB//NQ\\
\because&\begin{cases}
  PB//NQ\\
  NQ⊄平面PBC\\
  PB\subset 平面PBC\\
\end{cases}\therefore NQ//平面PBC\\
\because&\begin{cases}
  MQ//平面PBC\\
  NQ//平面PBC\\
  MQ\subset 平面PBC\\
  NQ\subset 平面PBC\\
  MQ\cap NQ=Q\\
\end{cases}\therefore 平面PBC//平面MNQ
\end{align*}</script></li><li><p>四边形$ABCD$是平行四边形, 点$P$是平面$ABCD$外一点, $M$是$PC$的中点, 在$DM$上取一点$G$,过$G$和AP$作平面交平面$BDM$于$GH$. 求证: $GH//$平面$PAD$<br><img data-src="/images/math_40.png" alt="40"></p></li></ul><h3 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h3><ul><li><p><img data-src="/images/math_41.png" alt="41"></p></li><li><p>补充:</p><ul><li>夹在平行平面之间的平行线段相等</li><li>两直线被三个平行平面所截, 截得的对应线段成比例</li></ul></li></ul><h2 id="8-6-空间直线、平面的垂直"><a href="#8-6-空间直线、平面的垂直" class="headerlink" title="8.6 空间直线、平面的垂直"></a>8.6 空间直线、平面的垂直</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h3><ul><li><p>空间两条直线夹角:$[0^\circ,90^\circ]$</p></li><li><p>平面两条直线夹角:$[0^\circ,90^\circ]$</p></li><li><p>异面直线夹角:$(0^\circ,90^\circ]$</p></li></ul><h3 id="2-线面垂直"><a href="#2-线面垂直" class="headerlink" title="2. 线面垂直"></a>2. 线面垂直</h3><ul><li>直线$l$与平面$\alpha$内任意一条直线垂直</li><li>$a\perp\alpha,b\subset\alpha\Rightarrow a\perp b$</li><li><img data-src="/images/math_43.png" alt="43"></li></ul><h3 id="3-线面垂直判定"><a href="#3-线面垂直判定" class="headerlink" title="3. 线面垂直判定"></a>3. 线面垂直判定</h3><ul><li><p>如果一条直线与一个平面内的<strong>两条相交直线</strong>垂直, 那么该直线与此平面垂直</p></li><li><p>$l\perp a, l\perp b, a\subset\alpha, b\subset\alpha,a\cap b=P\Rightarrow l\perp\alpha$</p></li><li><p><img data-src="/images/math_44.png" alt="44"></p></li></ul><h3 id="4-线面垂直性质"><a href="#4-线面垂直性质" class="headerlink" title="4. 线面垂直性质"></a>4. 线面垂直性质</h3><ul><li><p>垂直于同一平面的两条直线平行</p></li><li><p>$a\perp\alpha, b\perp\alpha\Rightarrow a//b$</p></li><li><p><img data-src="/images/math_46.png" alt="46"></p></li></ul><h3 id="5-线面角"><a href="#5-线面角" class="headerlink" title="5. 线面角"></a>5. 线面角</h3><ul><li><p><img data-src="/images/math_48.png" alt="48"></p></li><li><p>$l$是斜线(与平面有交点但不与平面垂直)</p></li><li><p>$A$是斜足</p></li><li><p>$O$是垂足(过$l$上不是斜足的点向平面做垂直的交点)</p></li><li><p>线面角即直线$AP$与射影$OA$的夹角$\theta$</p></li><li><p>$0^\circ\le\theta\le90^\circ$</p></li></ul><h3 id="6-三垂线定理"><a href="#6-三垂线定理" class="headerlink" title="6. 三垂线定理"></a>6. 三垂线定理</h3><ul><li><p>定理: 在平面内的一条直线, 如果和这个平面的一条斜线的射影垂直, 则和它的斜线垂直</p></li><li><p>逆定理: 在平面内的一条直线, 如果和这个平面的一条斜线垂直, 则和它的射影垂直</p></li><li><p><img data-src="/images/math_51.png" alt="51"></p></li><li><p>用时需证明: $\left. \begin{array}{r}<br>\left. \begin{array}{r}<br>\left. \begin{array}{r}<br>PA\bot \alpha\\<br>a\subset \alpha\\<br>\end{array} \right\} a\bot PA\\<br>a\bot AD\\<br>\end{array} \right\} a\bot 平面BAD\\<br>PO\subset 平面PAO\\<br>\end{array} \right\} a\bot PO$</p></li></ul><h3 id="7-二面角"><a href="#7-二面角" class="headerlink" title="7. 二面角"></a>7. 二面角</h3><ul><li><p>二面角: 从一条直线出发的<strong>两个半平面</strong>所组成的图形</p></li><li><p><img data-src="/images/math_50.png" alt="50"></p></li><li><p>记法: 二面角$\alpha-AB-\beta$或$\alpha-l-\beta$或$P-AB-Q$或$P-l-Q$</p></li><li><p>二面角的平面角: $O\in l, OA\subset\alpha, OB\subset\beta,OA\perp l, OB\perp l, \Rightarrow\angle AOB$为二面角$\alpha-l-\beta$的平面角</p></li><li><p>二面角的平面角确定方法</p><ul><li><ol><li>定义法: 棱上找一特殊点, 二平面分别向棱做垂线</li></ol></li><li><ol><li>垂角法: 做棱垂直的平面, 与半平面产生的交线</li></ol></li><li><ol><li>线面垂直法: $A\in\alpha, AB\perp\beta于P, BO\perp l于O$, 连接$OA$, $\angle AOB$为平面角或其补角<br><img data-src="/images/math_54.png" alt="54"></li></ol></li><li><ol><li>转化: $PA\perp\alpha, PB\perp\beta, \angle AOB+\angle P=180^\circ$<br><img data-src="/images/math_55.png" alt="55"></li></ol></li></ul></li></ul><h3 id="8-面面垂直判定"><a href="#8-面面垂直判定" class="headerlink" title="8. 面面垂直判定"></a>8. 面面垂直判定</h3><ul><li><p>如果一个平面过另一个平面的<strong>垂线</strong>, 那么这两个平面垂直</p></li><li><p><img data-src="/images/math_52.png" alt="52"></p></li><li><p>$a\perp\beta, a\subset\alpha\Rightarrow\alpha\perp\beta$</p></li></ul><h3 id="9-面面垂直性质"><a href="#9-面面垂直性质" class="headerlink" title="9. 面面垂直性质"></a>9. 面面垂直性质</h3><ul><li><p>两个平面垂直, 如果一个平面内有一直线垂直于这两个平面的<strong>交线</strong>, 那么这条直线与另一个平面<strong>垂直</strong></p></li><li><p>$\alpha\perp\beta, \alpha\cap\beta=l, a\subset\alpha, a\perp l\Rightarrow a\perp\beta$</p></li><li><p><img data-src="/images/math_56.png" alt="56"></p></li></ul><h3 id="整理-3"><a href="#整理-3" class="headerlink" title="整理"></a>整理</h3><ul><li><p>如图所示, 四面体$A-BCD$中, $E,F$分别是$AB,CD$的中点.若$BD,AC$所成的角为$60^\circ$, 且$BD=AC=2$,求$EF$的长度<br><img data-src="/images/math_42.png" alt="42"></p></li><li><p>如图所示, $Rt\triangle ABC$所在平面外有一点$S$, 且$SA=SB=SC$, 点$D$为斜边$AC$的中点<br>(1)求证: $SD\perp$平面$ABC$;<br>(2)若$AB=BC$, 求证: $BD\perp$平面$SAC$<br><img data-src="/images/math_45.png" alt="45"></p></li><li><p>正方形$ABCD-A_1B_1C_1D_1$中, $EF$与异面直线$AC,A_1D$都垂直相交, 求证: $EF//BD_1$<br><img data-src="/images/math_47.png" alt="47"></p></li><li><p>$AB$为$\circ O$的直径, $PA$垂直于$\circ O$所在的平面, $M$为圆周上任意一点, $AN\perp PM,N$为垂足<br>(1)求证: $AN\perp$平面$PBM$<br>(2)若$AQ\perp PB$, 垂足为Q, 求证: $NQ\perp PB$<br><img data-src="/images/math_49.png" alt="49"></p></li><li><p>正方形$ABCD$, $PA\perp$平面$ABCD$, $PA=PB$, 求二面角$B-PC-D$的平面角的度数<br><img data-src="/images/math_53.png" alt="53"></p></li><li><p>过点$S$引三条线段$SA, SB, SC$, 其中$\angle BSC=90^\circ,\angle ASC=\angle BSA=60^\circ$, 且$SA=SB=SC=a$<br>求证:平面$ABC\perp$平面$BSC$</p></li></ul>]]></content>
      <categories>
        <category>文化课</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Next主题评论区不显示的问题</title>
    <url>/solve-next-theme-comments-disappear/</url>
    <content><![CDATA[<p>今天在搞博客的评论汐统，使用Valine，踩了敲多的坑(不知道是不是我脸黑)。来说说怎么解决的吧。</p><a id="more"></a><h3 id="一-返回404-101"><a href="#一-返回404-101" class="headerlink" title="一. 返回404(101)"></a>一. 返回404(101)</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>网页摁<code>F12</code>，在<code>Console</code>里有404提示，但是在<code>Response</code>里提示错误Code是<code>101</code>。</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>上网查了一下，发现如果同时使用Valine的评论和阅读统计时，要在<code>Leancloud</code>应用的<code>储存</code>的<code>结构化数据</code>里，分别新建两个名字为<code>Comment</code>和<code>Counter</code>的<code>Class</code>(分别用作储存评论和阅读计数)。</p><h3 id="二-网页无评论区"><a href="#二-网页无评论区" class="headerlink" title="二. 网页无评论区"></a>二. 网页无评论区</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>如图所示: <img data-src="/images/Next_no_comments_1.png" alt="Situation"></p><p>有评论区但是就是不显示</p><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>调了半天不能解决。既然不能靠主题生成，为什么不能把别人生成好的拿过来呢？</p><p>打开百度，搜索<code>Hexo Next Valine</code>，找到一个有Valine的博客，查看网页源代码，把Valine那一块复制下来。</p><p>复制的长这样：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    NexT.utils.loadComments(<span class="built_in">document</span>.querySelector(<span class="string">'#valine-comments'</span>), () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">      NexT.utils.getScript(<span class="string">'//unpkg.com/valine/dist/Valine.min.js'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">       <span class="keyword">var</span> GUEST = [<span class="string">'nick'</span>, <span class="string">'mail'</span>, <span class="string">'link'</span>];</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> guest = <span class="string">'nick,mail,link'</span>;</span></span><br><span class="line"><span class="javascript">        guest = guest.split(<span class="string">','</span>).filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> GUEST.includes(item);</span></span><br><span class="line">        &#125;);</span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Valine(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#valine-comments'</span>,</span></span><br><span class="line"><span class="actionscript">        verify: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">        notify: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">        appId: <span class="string">'你的appId'</span>,</span></span><br><span class="line"><span class="actionscript">        appKey: <span class="string">'你的appKey'</span>,</span></span><br><span class="line"><span class="actionscript">        placeholder: <span class="string">"添加评论"</span>,</span></span><br><span class="line"><span class="actionscript">        avatar: <span class="string">'hide'</span>,</span></span><br><span class="line">        meta: guest,</span><br><span class="line"><span class="actionscript">        pageSize: <span class="string">'10'</span> || <span class="number">10</span>,</span></span><br><span class="line"><span class="actionscript">        visitor: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">        lang: <span class="string">''</span> || <span class="string">'zh-cn'</span>,</span></span><br><span class="line">        path: location.pathname,</span><br><span class="line"><span class="actionscript">        recordIP: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">        serverURLs: <span class="string">''</span></span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">    &#125;, <span class="built_in">window</span>.Valine);</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>把复制下来的内容替换<code>blog/themes/next/layout/_third-party/comments/valine.swig</code>中长得跟这块很像的东西。</p><p><strong>之后更改<code>Valine</code>配置时在这个文件改而不是在主题的<code>_config.yml</code>中改</strong></p><p>然后<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>就行了。</p><p>另外，在<code>&lt;/script&gt;</code>前加上</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var infoEle = document.querySelector('#valine-comments .info');</span><br><span class="line">    if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123;</span><br><span class="line">      infoEle.childNodes.forEach(function(item) &#123;</span><br><span class="line">        item.parentNode.removeChild(item);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>即可去除<code>Powered by Valine.</code>。</p><p>如果去除无效，请将CDN上的<code>Valine.min.js</code>下载到<code>blog/themes/next/source/js/src</code>中，并在<code>Next</code>设置中将Valine的CDN设为<code>/js/src/Valine.min.js</code>。打开下载的<code>js</code>文件，搜索<code>Powered</code>，在搜索结果附近找到<code>&lt;div class=&quot;power txt-right&quot;&gt;Powered By &lt;a href=&quot;https://valine.js.org&quot; target=&quot;_blank&quot;&gt;Valine&lt;/a&gt;&lt;br&gt;v&#39;+o</code>并删掉即可。</p><p>这样处理后，最后我的<code>valine.swig</code>长这样</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn1.lncld.net/static/js/3.0.4/av-min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  &#123;% set valine_uri = '/js/src/Valine.min.js' %&#125;</span><br><span class="line">  &#123;% if theme.vendors.valine %&#125;</span><br><span class="line">    &#123;% set valine_uri = theme.vendors.valine %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123; &#123; valine_uri &#125; &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    NexT.utils.loadComments(<span class="built_in">document</span>.querySelector(<span class="string">'#valine-comments'</span>), () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">      NexT.utils.getScript(<span class="string">'//unpkg.com/valine/dist/Valine.min.js'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">       <span class="keyword">var</span> GUEST = [<span class="string">'nick'</span>, <span class="string">'mail'</span>, <span class="string">'link'</span>];</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> guest = <span class="string">'nick,mail,link'</span>;</span></span><br><span class="line"><span class="javascript">        guest = guest.split(<span class="string">','</span>).filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> GUEST.includes(item);</span></span><br><span class="line">        &#125;);</span><br><span class="line"><span class="actionscript">      <span class="keyword">new</span> Valine(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#valine-comments'</span>,</span></span><br><span class="line"><span class="actionscript">        verify: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">        notify: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">        appId: <span class="string">'TXFun2tTdkrFHCo8SPKrI5a8(appId)'</span>, <span class="comment">//记得带引号</span></span></span><br><span class="line"><span class="actionscript">        appKey: <span class="string">'VRbgL04C09q5aRk(appKey)'</span>,<span class="comment">//记得带引号</span></span></span><br><span class="line"><span class="actionscript">        placeholder: <span class="string">"添加评论"</span>,</span></span><br><span class="line"><span class="actionscript">        avatar: <span class="string">'hide'</span>,</span></span><br><span class="line">        meta: guest,</span><br><span class="line"><span class="actionscript">        pageSize: <span class="string">'10'</span> || <span class="number">10</span>,</span></span><br><span class="line"><span class="actionscript">        visitor: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">        lang: <span class="string">''</span> || <span class="string">'zh-cn'</span>,</span></span><br><span class="line">        path: location.pathname,</span><br><span class="line"><span class="actionscript">        recordIP: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">        serverURLs: <span class="string">''</span></span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">    &#125;, <span class="built_in">window</span>.Valine);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> infoEle = <span class="built_in">document</span>.querySelector(<span class="string">'#valine-comments .info'</span>);</span></span><br><span class="line">    if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123;</span><br><span class="line"><span class="actionscript">      infoEle.childNodes.forEach(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> </span>&#123;</span></span><br><span class="line">        item.parentNode.removeChild(item);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>清北澡堂2020十一刷题Day1解题报告</title>
    <url>/%E5%8D%81%E4%B8%80%E5%88%B7%E9%A2%98Day1/</url>
    <content><![CDATA[<h2 id="清北澡堂2020十一刷题Day1-解题报告"><a href="#清北澡堂2020十一刷题Day1-解题报告" class="headerlink" title="清北澡堂2020十一刷题Day1 解题报告"></a>清北澡堂2020十一刷题Day1 解题报告</h2><a id="more"></a><h3 id="思路题-T1-打扑克"><a href="#思路题-T1-打扑克" class="headerlink" title="[思路题]T1 打扑克"></a>[思路题]T1 打扑克</h3><blockquote><p><strong>我是sb</strong><br>一道sb题 推了2+hours 啥也不会</p></blockquote><p>分情况讨论，大概就是$<br>\begin{cases}<br>n为偶数\begin{cases}奇数先出\\偶数先出\end{cases}\\<br>n为奇数\begin{cases}奇数先出\\偶数先出\end{cases}\\<br>\end{cases}<br>$</p><p>首先，我们可以把奇数组中的$n$和偶数组中的$n+1$划到一个组中</p><p>默认「你」是先出的那一方</p><h4 id="n-为奇数"><a href="#n-为奇数" class="headerlink" title="$n$为奇数"></a>$n$为奇数</h4><p>以$\begin{align<em>}1\qquad2\\3\qquad4\\5\qquad\ \ \\\end{align</em>}$为例</p><h5 id="奇数先出"><a href="#奇数先出" class="headerlink" title="奇数先出"></a>奇数先出</h5><p>可以发现，如果从最小的数$1$开始从小到大出，最后会剩下$5$出不去($1-2,\ 3-4,\ \cdots$)</p><p>所以要创造一次偶数方无法出牌的情况，来使多余的那张牌出去</p><p>只要先将最大点数的牌出掉，然后再出剩下的牌，对手出$n$，你就出$n+1$，即为必胜策略</p><p>即$ans_{n \&amp; 1 == 1 \&amp;\&amp;op\&amp;1==0}=0$</p><h5 id="偶数先出"><a href="#偶数先出" class="headerlink" title="偶数先出"></a>偶数先出</h5><p>只要你先出，对手总会有一张牌出不掉</p><p>所以$ans_{n \&amp; 1 == 1 \&amp;\&amp;op\&amp;1==1}=1$</p><p>所以，$ans_{n\&amp;1==1}=op$</p><h4 id="n-为偶数"><a href="#n-为偶数" class="headerlink" title="$n$为偶数"></a>$n$为偶数</h4><p>以$\begin{align<em>}1\qquad2\\3\qquad4\\5\qquad6\\\end{align</em>}$为例</p><h5 id="n-2​"><a href="#n-2​" class="headerlink" title="n == 2​"></a>n == 2​</h5><p>先手必胜</p><h5 id="奇数先出-1"><a href="#奇数先出-1" class="headerlink" title="奇数先出"></a>奇数先出</h5><p>对手的必胜策略是，不管你第一步出的什么，对手都出最大的一张牌</p><p>这样不管你怎样出，也会剩下一张牌出不出去</p><p>所以$ans_{n \&amp; 1 == 0 \&amp;\&amp; op\&amp;1==1} = 1$</p><h5 id="偶数先出-1"><a href="#偶数先出-1" class="headerlink" title="偶数先出"></a>偶数先出</h5><p>按上面的必胜策略出即可</p><p>所以，$ans_{n \&amp; 1 == 0}=\begin{cases}op&amp;n==2\\1&amp;n\neq2\end{cases}$</p><p>综上，$ans=\begin{cases}op&amp;n==2或n为奇数\\1&amp;n为偶数且n\neq2\end{cases}$</p><h3 id="思路题-T2-粉刷匠"><a href="#思路题-T2-粉刷匠" class="headerlink" title="[思路题]T2 粉刷匠"></a>[思路题]T2 粉刷匠</h3><blockquote><p>emm 妙啊</p></blockquote><h4 id="Subtask-1-30pts"><a href="#Subtask-1-30pts" class="headerlink" title="Subtask 1: 30pts"></a>Subtask 1: 30pts</h4><p>暴力模拟即可</p><h4 id="Subtask-2-60pts"><a href="#Subtask-2-60pts" class="headerlink" title="Subtask 2: 60pts"></a>Subtask 2: 60pts</h4><p>听说开10棵线段树，维护即可</p><h4 id="100pts"><a href="#100pts" class="headerlink" title="100pts"></a>100pts</h4><p>首先，最后的答案只与最后粉刷的颜色有关，所以可以倒序处理染色操作</p><p>如图，最后<img data-src="/images/qbxt-golden-week-problem-solving-practice-day1_1.png" alt="1">的粉刷结果可以转化为<img data-src="/images/qbxt-golden-week-problem-solving-practice-day1_2.png" alt="2">这样的结果(圈为染成蓝色的点)</p><p>所以，可以一边刷墙一边统计答案，因为染色过的格子，再次染色不会受到影响</p><p>所以染过某一行或者某一列之后，可以直接<code>--行数</code>或者<code>--列数</code>，在这之前，要统计答案</p><h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">	<span class="keyword">if</span> (!vis[x[i]][y[i]]) &#123;</span><br><span class="line">		vis[x[i]][y[i]] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (z[i])</span><br><span class="line">			ans += n[!x[i]]; <span class="comment">//n[0]为行数, n[1]为列数</span></span><br><span class="line">		--n[x[i]];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><h3 id="暴力辗标算-T3-直线竞速"><a href="#暴力辗标算-T3-直线竞速" class="headerlink" title="[暴力辗标算]T3 直线竞速"></a>[暴力辗标算]T3 直线竞速</h3><blockquote><p>暴力碾标算?</p><p>没开<code>long long</code>见祖宗</p></blockquote><h4 id="100pts-1"><a href="#100pts-1" class="headerlink" title="100pts #1"></a>100pts #1</h4><p>就是每次计算所有人当前时间的位置<code>pos</code></p><p>用<code>sort</code>或者<code>nth_element</code>对<code>pos</code>排序求即可</p><h4 id="100pts-2"><a href="#100pts-2" class="headerlink" title="100pts #2"></a>100pts #2</h4><p>显然，每两个选手之间，交换排名的次数至多有一次</p><p>所以总交换次数为$\dfrac{n\cdot(n-1)}{2}$</p><p>所以可以按时间把每次询问排序，</p><p>每次询问冒泡排序选手位置即可</p><p>课件中说：</p><blockquote><p>总的交换次数是$O(n^2)$的</p><p>时间复杂度$O(n^2+nQ+QlogQ)$</p></blockquote><h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> l = j; l &gt; <span class="number">1</span>; --l) &#123; <span class="comment">//冒泡排序</span></span><br><span class="line">			x = people[l].pos + <span class="number">1l</span>l * people[l].v * req[i].t,</span><br><span class="line">			y = people[l - <span class="number">1</span>].pos + <span class="number">1l</span>l * people[l - <span class="number">1</span>].v * req[i].t;</span><br><span class="line">			<span class="keyword">if</span> (x &gt; y || (x == y &amp;&amp; people[l].id &lt; people[l - <span class="number">1</span>].id))</span><br><span class="line">				swap(people[l], people[l - <span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	req[i].ans = people[req[i].p].id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>清北澡堂2020十一刷题Day6解题报告</title>
    <url>/%E5%8D%81%E4%B8%80%E5%88%B7%E9%A2%98Day6/</url>
    <content><![CDATA[<h2 id="清北澡堂2020十一刷题Day6-解题报告"><a href="#清北澡堂2020十一刷题Day6-解题报告" class="headerlink" title="清北澡堂2020十一刷题Day6 解题报告"></a>清北澡堂2020十一刷题Day6 解题报告</h2><a id="more"></a><h3 id="数竞题-T1-math"><a href="#数竞题-T1-math" class="headerlink" title="[数竞题?]T1 math"></a>[数竞题?]T1 <a href="http://csp.ac/contest/42/problem/285" target="_blank" rel="noopener">math</a></h3><blockquote><p>小蓝本救命</p></blockquote><h4 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h4><p>求$\gcd(q^a-1,q^b-1)\mod p$</p><h4 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h4><p>辗转相除法的原理是$\gcd{(a, b)} = \gcd{(b, a\mod b)}$，其实就是$\gcd{(a, b)} = \gcd{(b, a-b-b-\cdots-b)}=\gcd{(b, a-\lfloor\frac{a}{b}\rfloor\cdot b)}$</p><p>假设$a&gt;b$，原式可以化为$\gcd(q^b-1, q^a-q^b)$</p><p>其中，$q^a-q^b=q^b\cdot(q^{a-b}-1)$，又因为$q^b-1$一定与$q^b$互质，所以$\gcd(q^b-1, q^a-q^b)=\gcd(q^b-1,q^{a-b}-1)$</p><p>我们再次使$a’=b,b’=a-b$，上式可以化成$\gcd{(q^{a’}-1, q^{b’}-1)}$，一直推下去，可以得到</p><p>$\gcd(q^a-1,q^b-1)=\gcd{(q^0-1,q^{\gcd{(a,b)} }-1)}=q^{\gcd{(a,b)} }-1$(参考辗转相除法的做法)</p><p>最后注意判断下答案小于$0$时的输出即可</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">res = ksm(q, gcd(a, b), p) - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res &lt; <span class="number">0</span> ? res + p : res);</span><br></pre></td></tr></table></figure><h3 id="T2-candy"><a href="#T2-candy" class="headerlink" title="T2 candy"></a>T2 candy</h3><p>其实正解就是暴力优化一下</p><p>想到<code>Dinic</code>里的当前弧优化</p><p>令$cur_t$表示当前$t$能吃的最后一个糖果</p><p>下次从这里开始找即可</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp; n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp; t),</span><br><span class="line">    ++cnt[t];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp; m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp; t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = curl[t]; j &lt;= <span class="number">1e6</span>; j += t)</span><br><span class="line">        <span class="keyword">if</span> (cnt[j]) &#123;</span><br><span class="line">            ans[i] = j,</span><br><span class="line">            --cnt[j],</span><br><span class="line">            curl[t] = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ans[i]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然似乎也可以预处理一下每个数的因子</p><h3 id="T3-lagrange"><a href="#T3-lagrange" class="headerlink" title="T3 lagrange"></a>T3 lagrange</h3><blockquote><p>推式子真快乐</p></blockquote><h4 id="大意-1"><a href="#大意-1" class="headerlink" title="大意"></a>大意</h4><p>给定$A_i,B_i$，带修改$A_i,B_i$，</p><p>求$\sum\limits_{l\leq i &lt; j\leq r}{(A_iB_j-A_jB_i)^2} \mod 998244353$</p><h4 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h4><p>首先对原式展开平方，得到</p><script type="math/tex;mode=display">\sum\limits_{i<j}{(A_iB_j-A_jB_i)^2}=\sum\limits_{i<j}{(A_i^2B_j^2+A_j^2B_i^2)}-2\sum\limits_{i<j}{A_iA_jB_iB_j}</script><p>把它分成左右两个部分</p><p>对于左边部分，可以借助容斥的思想进行变换，得到<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><script type="math/tex;mode=display">\sum\limits_{i<j}{(A_i^2B_j^2+A_j^2B_i^2)}=\sum\limits_{i\neq j}{A_i^2B_j^2}=\sum{A_i^2B_j^2}-\sum{A_i^2B_i^2}</script><p>右边部分，我们设$C_i=A_iB_i$，那么有<sup><a href="#fn_2" id="reffn_2">2</a></sup></p><script type="math/tex;mode=display">2\sum\limits_{i<j}{A_iA_jB_iB_j}=\sum\limits_{i\neq j}{C_iC_j}=\sum{C_iC_j}-\sum{C_i^2}</script><p>将$C_i=A_iB_i$带入，得到</p><script type="math/tex;mode=display">2\sum\limits_{i\neq j}{A_iA_jB_iB_j}=\sum{A_iA_jB_iB_j}-\sum{A_i^2B_i^2}</script><p>所以，原式</p><script type="math/tex;mode=display">\begin{align*}
&=\sum{A_i^2B_j^2}-\sum{A_i^2B_i^2}-\sum{A_iA_jB_iB_j}+\sum{A_i^2B_i^2}\\
&=\sum{(A_i^2B_j^2-A_iA_jB_iB_j)}\\
&=\sum{A_i^2}\cdot\sum{B_i^2}-(\sum{A_iB_i})^2\\
\end{align*}</script><script type="math/tex;mode=display">\therefore\ \sum\limits_{l\leq i < j\leq r}{(A_iB_j-A_jB_i)^2}=\sum\limits_{l\leq i\leq r}{A_i^2}\cdot\sum\limits_{l\leq i\leq r}{B_i^2}-(\sum\limits_{l\leq i\leq r}{A_iB_i})^2</script><p>使用树状数组进行维护即可（其实这玩意就是<a href="https://baike.baidu.com/item/拉格朗日恒等式/7350857?fr=aladdin#恒等式内容" target="_blank" rel="noopener">拉格朗日恒等式</a>）</p><blockquote id="fn_1"><sup>1</sup>. $\begin{align<em>}\sum{a_i}\cdot\sum{b_i}&amp;=(a_1\cdot a_2\cdots a_n)\cdot(b_1\cdot b_2\cdots b_n)\\&amp;=a_1b_1+a_1b_2+\cdots+a_nb_n\\&amp;=\sum\limits_{i,j}{a_ib_j}\\&amp;=\sum\limits_{i&lt;j}{(a_ib_j+a_jb_i)}+\sum{a_ib_i}\\&amp;=\sum\limits_{i\leq j}{(a_ib_j+a_jb_i)}-\sum{a_ib_i}\end{align</em>}$<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2"><sup>2</sup>. $\begin{align<em>}&amp;\because c_i=c_j\\&amp;\therefore c_i\cdot c_j=c_j\cdot c_i\\&amp;\therefore\sum\limits_{i&lt;j}{c_i\cdot c_j}=\frac{\sum{c_i}\cdot\sum{c_i}-\sum{c_i^2} }{2}\\&amp;\quad\sum\limits_{i&lt;j}{c_i\cdot c_j}=\frac{\sum{c_i}\cdot\sum{c_i}-\sum{c_i^2} }{2}\end{align</em>}$<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a></blockquote><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><p>及时取模 别爆<code>long long</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">read(n, q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    read(a[i]),</span><br><span class="line">    a[i] %= mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    read(b[i]),</span><br><span class="line">    b[i] %= mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    update(treea, i, a[i] * a[i] % mod),</span><br><span class="line">    update(treeb, i, b[i] * b[i] % mod),</span><br><span class="line">    update(treeab, i, a[i] * b[i] % mod);</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line">    read(opt);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">        read(l, r),</span><br><span class="line">        res = query(treea, l, r) % mod * query(treeb, l, r) % mod - <span class="built_in">pow</span>(query(treeab, l, r) % mod);</span><br><span class="line">        <span class="keyword">while</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">            res += mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        read(x, l, r),</span><br><span class="line">        update(treea, x, (l % mod * l % mod) - (a[x] * a[x] % mod)),</span><br><span class="line">        update(treeb, x, (r % mod * r % mod) - (b[x] * b[x] % mod)),</span><br><span class="line">        update(treeab, x, (l % mod * r % mod) - (a[x] * b[x] % mod)),</span><br><span class="line">        a[x] = l % mod,</span><br><span class="line">        b[x] = r % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析 作业2</title>
    <url>/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A2/</url>
    <content><![CDATA[<p>第二周作业</p><a id="more"></a><h3 id="1-证：一张图的所有边权互不相同时，最小生成树唯一"><a href="#1-证：一张图的所有边权互不相同时，最小生成树唯一" class="headerlink" title="1. 证：一张图的所有边权互不相同时，最小生成树唯一"></a>1. 证：一张图的所有边权互不相同时，最小生成树唯一</h3><p>假设$G$有两个不同的最小生成树$T$，$T’$，$e(T)=\{e_1, e_2,\cdots, e_m\}, e(T’)=\{e’_1, e’_2,\cdots, e’_m\}$</p><p>设$e_k$满足$e_k\neq e’_k$且$k$是满足条件的最小值，由于边权均不相同，不妨设$w(e_k)&lt;w(e’_k)$</p><p>将$e_k$加入$T’$中，则$T’$会构成环，且满足环中不含边$e’_1, e’_2,\cdots, e’_{k-1}$（否则$T$中$e_1, e_2,\cdots, e_k$会构成环）</p><p>将$T’$中环任意非$e_k$的边删去即可得到比$T’$更小的生成树，与$T’$是最小生成树矛盾</p><p>得证。</p><h3 id="2-Fredman-amp-Tarjan算法"><a href="#2-Fredman-amp-Tarjan算法" class="headerlink" title="2. Fredman &amp; Tarjan算法"></a>2. Fredman &amp; Tarjan算法</h3><h4 id="a-写出Fredman-amp-Tarjan算法的伪代码"><a href="#a-写出Fredman-amp-Tarjan算法的伪代码" class="headerlink" title="(a) 写出Fredman &amp; Tarjan算法的伪代码"></a>(a) 写出Fredman &amp; Tarjan算法的伪代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fredman_and_Tarjan</span><span class="params">(G)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> u <span class="keyword">in</span> G.Node:</span><br><span class="line">        mark[u] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        increase = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> G.Node:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mark[u]:</span><br><span class="line">                u_now = u</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> u_now == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        added_edge = Prim_Once(G, u_now)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> added_edge == <span class="literal">True</span> <span class="keyword">or</span> len(C[u_now]) &gt;= K:</span><br><span class="line">            <span class="keyword">for</span> u <span class="keyword">in</span> C[u_now]:</span><br><span class="line">                mark[u] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    G_new = Contract_Nodes(G, C) <span class="comment"># make connection a node</span></span><br><span class="line">    <span class="keyword">if</span> len(G_new.Node) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> G_new</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	<span class="keyword">return</span> Fredman_and_Tarjan(G_new)</span><br></pre></td></tr></table></figure><h4 id="b-证明Fredman-amp-Tarjan的时间复杂度是-O-m-log-n"><a href="#b-证明Fredman-amp-Tarjan的时间复杂度是-O-m-log-n" class="headerlink" title="(b) 证明Fredman &amp; Tarjan的时间复杂度是$O(m\log^*{n})$"></a>(b) 证明Fredman &amp; Tarjan的时间复杂度是$O(m\log^*{n})$</h4><h5 id="一轮的时间代价为-O-m-n-log-K"><a href="#一轮的时间代价为-O-m-n-log-K" class="headerlink" title="一轮的时间代价为$O(m+n\log{K})$"></a>一轮的时间代价为$O(m+n\log{K})$</h5><p>每条边最多被枚举$2$次，时间代价$O(m)$</p><p>最多枚举$n$个点，寻找最小值时堆中最多有$K$个元素，代价$O(\log{K})$，这部分时间代价$O(n\log{K})$</p><p>所以，一轮的时间代价为$O(m+n\log{K})$</p><h5 id="通过设定每轮-K-i-的值，实际一轮的时间代价为-O-m"><a href="#通过设定每轮-K-i-的值，实际一轮的时间代价为-O-m" class="headerlink" title="通过设定每轮$K_i$的值，实际一轮的时间代价为$O(m)$"></a>通过设定每轮$K_i$的值，实际一轮的时间代价为$O(m)$</h5><p>首先有$2m=\sum\limits_{u}{d_u}=\sum\limits_i^l{\sum\limits_{u\in{C_i} } }{d_u}\geq\sum\limits_{i=1}^{l} {K}=Kl$，所以$l\leq \frac{2m}{K}$</p><p>我们设，在第$i$轮，有$n_i\leq n$个点，$m_i\leq m$个边，$K_i:=2^\frac{2m}{n_i}$</p><p>那么这一轮的时间代价为$O(m_i+n_i\log{K_i})=O(m_i+n_i\frac{2m}{n_i})=O(m)$</p><h5 id="最多进行-log-n-轮"><a href="#最多进行-log-n-轮" class="headerlink" title="最多进行$\log^*{n}$轮"></a>最多进行$\log^*{n}$轮</h5><p>由于缩点，所以有$n_{i+1}&lt;n_{i}&lt;n, m_{i+1}&lt;m_{i}&lt;m$，所以$K_i\leq \frac{2m}{n_i+1}=\log{K_{i+1} }\Rightarrow K_{i+1}\geq 2^{K_i}$</p><p>也就是在$\log^*{n}$次后，$K$的值至少为$n$，此时这棵生成树已经有$n$个点了</p><p>所以，Fredman &amp; Tarjan的时间复杂度是$O(m\log^*{n})$</p><h3 id="3-Boruvka算法"><a href="#3-Boruvka算法" class="headerlink" title="3. Borůvka算法"></a>3. Borůvka算法</h3><h4 id="a-写出Boruvka算法中，用-O-m-的时间进行一轮缩点（contraction）的伪代码"><a href="#a-写出Boruvka算法中，用-O-m-的时间进行一轮缩点（contraction）的伪代码" class="headerlink" title="(a) 写出Borůvka算法中，用$O(m)$的时间进行一轮缩点（contraction）的伪代码"></a>(a) 写出Borůvka算法中，用$O(m)$的时间进行一轮缩点（contraction）的伪代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Contraction</span><span class="params">(G)</span>:</span></span><br><span class="line">    G_new = new Graph()</span><br><span class="line">    UF = new Union_Find()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> G.E:</span><br><span class="line">        <span class="keyword">if</span> e.blue == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> UF.fa[e.u] != UF.fa[e.v]:</span><br><span class="line">                UF.union(e.u, e.v)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> G.E:</span><br><span class="line">        root_u = UF.fa[e.u]</span><br><span class="line">        root_v = UF.fa[e.v]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root_u <span class="keyword">not</span> <span class="keyword">in</span> G_new.V:</span><br><span class="line">            G_new.V.append(root_u)</span><br><span class="line">        <span class="keyword">if</span> root_v <span class="keyword">not</span> <span class="keyword">in</span> G_new.V:</span><br><span class="line">            G_new.V.append(root_v)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> root_u != root_v:</span><br><span class="line">            <span class="keyword">if</span> root_u &gt; root_v:</span><br><span class="line">                swap(root_u, root_v)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> (root_u, root_v) <span class="keyword">not</span> <span class="keyword">in</span> G_new.E:</span><br><span class="line">                G_new.E[(root_u, root_v)] = e.w</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                G_new.E[(root_u, root_v)] = min(G_new.E[(root_u, root_v)], e.w)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> G_new</span><br></pre></td></tr></table></figure><h4 id="b-Boruvka算法每轮会把节点的数量减少一个常数倍，但是边的数量呢？构造一张-n-个节点-m-条边的图，使得在经过-Omega-log-n-轮缩点后的图的边数依然是-Omega-m-，即便清除过重边和自环"><a href="#b-Boruvka算法每轮会把节点的数量减少一个常数倍，但是边的数量呢？构造一张-n-个节点-m-条边的图，使得在经过-Omega-log-n-轮缩点后的图的边数依然是-Omega-m-，即便清除过重边和自环" class="headerlink" title="(b) Borůvka算法每轮会把节点的数量减少一个常数倍，但是边的数量呢？构造一张$n$个节点$m$条边的图，使得在经过$\Omega(\log{n})$轮缩点后的图的边数依然是$\Omega(m)$，即便清除过重边和自环"></a>(b) Borůvka算法每轮会把节点的数量减少一个常数倍，但是边的数量呢？构造一张$n$个节点$m$条边的图，使得在经过$\Omega(\log{n})$轮缩点后的图的边数依然是$\Omega(m)$，即便清除过重边和自环</h4><p>不会，经过$\Omega(\log{n})$轮后，顶点数都趋近于$1$了，哪来的这么多边（</p><p>虽说如果是完全图的话，初始$m=n(n-1),O(m)=O(n^2)$，第$i$轮过后$m_i$最多也是$n_i(n_i-1)$。嗯，都是$O(n^2)$，合理…</p><h4 id="c-证明运行-log-log-n-轮Boruvka算法后，使用斐波那契堆（Fibonacci-Heap）实现的Prim算法求-MST的时间复杂度是-O-m-log-log-n"><a href="#c-证明运行-log-log-n-轮Boruvka算法后，使用斐波那契堆（Fibonacci-Heap）实现的Prim算法求-MST的时间复杂度是-O-m-log-log-n" class="headerlink" title="(c) 证明运行$\log{\log{n} }$轮Borůvka算法后，使用斐波那契堆（Fibonacci Heap）实现的Prim算法求 MST的时间复杂度是$O(m \log{\log{n} })$"></a>(c) 证明运行$\log{\log{n} }$轮Borůvka算法后，使用斐波那契堆（Fibonacci Heap）实现的Prim算法求 MST的时间复杂度是$O(m \log{\log{n} })$</h4><p>标记边一轮时间复杂度为$O(2m)$，缩点一轮时间复杂度为$O(m)$，运行$\log{\log{n} }$轮的时间复杂度为$O(m \log{\log{n} })$，最多剩余点数$n’$为$n’=\dfrac{n}{2^{\log{\log{n} } } }=\dfrac{n}{\log{n} }$，最多剩余边数$m’$为$O(m)$量级</p><p>当Prim算法使用斐波那契堆进行实现时，其时间复杂度为:</p><script type="math/tex;mode=display">O(m' + n' \log n')=O(m+\dfrac{n}{\log{n} }\cdot\log{\dfrac{n}{\log{n} } })=O(m+\dfrac{n}{\log{n} }(\log{n} - \log{\log{n} } ))=O(m+n-\dfrac{n\log{\log{n} } }{\log{n} })<O(m+n)</script><p>所以总时间复杂度$&lt;O(m \log{\log{n}+m+n})=O(m \log{\log{n} })$</p><p>得证</p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><h4 id="a-假设每个节点的邻接表已经按照边权升序排好。修改Boruvka算法使它的复杂度变为-O-m-n-log-n"><a href="#a-假设每个节点的邻接表已经按照边权升序排好。修改Boruvka算法使它的复杂度变为-O-m-n-log-n" class="headerlink" title="(a). 假设每个节点的邻接表已经按照边权升序排好。修改Borůvka算法使它的复杂度变为$O(m+n\log{n})$"></a>(a). 假设每个节点的邻接表已经按照边权升序排好。修改Borůvka算法使它的复杂度变为$O(m+n\log{n})$</h4><p>缩点：直接枚举所有点，取邻接表中的第一条边进行缩边，单轮时间复杂度$O(n)$，缩点$\log{n}$轮的总时间复杂度为$O(n\log{n})$</p><p>连边：按先第$j$条边再第$i$个点的顺序枚举所有边，当枚举到某点连出去的边的边权比这个点所在连通块已知的连出的最大边权还大、且该连通块没有未连接的连通块时，遇到这个点就continue掉；当所有连通块都连接时可break；否则继续边权取min或连边。$O(m)$</p><p>总时间复杂度为$O(m+n\log{n})$</p><h4 id="b-给定一个长度为-N-的序列和一个参数-k-，给出一个-O-N-log-k-的算法将序列分为-k-个组-g-1-g-2-cdots-g-k-，每个组的元素个数最多-lceil-frac-Nk-rceil-，并且所有-g-i-中的元素均小于-g-i-1-中的元素"><a href="#b-给定一个长度为-N-的序列和一个参数-k-，给出一个-O-N-log-k-的算法将序列分为-k-个组-g-1-g-2-cdots-g-k-，每个组的元素个数最多-lceil-frac-Nk-rceil-，并且所有-g-i-中的元素均小于-g-i-1-中的元素" class="headerlink" title="(b) 给定一个长度为$N$的序列和一个参数$k$，给出一个$O(N\log k)$的算法将序列分为$k$个组$g_1,g_2,\cdots,g_k$，每个组的元素个数最多$\lceil \frac Nk\rceil$，并且所有$g_i$中的元素均小于$g_{i+1}$中的元素"></a>(b) 给定一个长度为$N$的序列和一个参数$k$，给出一个$O(N\log k)$的算法将序列分为$k$个组$g_1,g_2,\cdots,g_k$，每个组的元素个数最多$\lceil \frac Nk\rceil$，并且所有$g_i$中的元素均小于$g_{i+1}$中的元素</h4><h4 id="c-假设每个节点的领接表已经按照-b-中的算法排好序。修改-a-的算法使它的复杂度变为-O-m-frac-mk-log-n-n-log-n"><a href="#c-假设每个节点的领接表已经按照-b-中的算法排好序。修改-a-的算法使它的复杂度变为-O-m-frac-mk-log-n-n-log-n" class="headerlink" title="(c) 假设每个节点的领接表已经按照(b)中的算法排好序。修改(a)的算法使它的复杂度变为$O(m+\frac mk\log{n}+n\log{n})$"></a>(c) 假设每个节点的领接表已经按照(b)中的算法排好序。修改(a)的算法使它的复杂度变为$O(m+\frac mk\log{n}+n\log{n})$</h4><h4 id="d-令-k-log-n-，证明：若-m-geq-n-log-n-，则-c-中的算法复杂度为-O-m-log-log-n-。并给出一种算法，-使得对于任意-m-，都能达到-O-m-log-log-n"><a href="#d-令-k-log-n-，证明：若-m-geq-n-log-n-，则-c-中的算法复杂度为-O-m-log-log-n-。并给出一种算法，-使得对于任意-m-，都能达到-O-m-log-log-n" class="headerlink" title="(d)  令$k=\log{n}$，证明：若$m\geq n\log{n}$，则(c)中的算法复杂度为$O(m\log{\log{n} })$。并给出一种算法， 使得对于任意$m$，都能达到$O(m\log{\log{n} })$"></a>(d) 令$k=\log{n}$，证明：若$m\geq n\log{n}$，则(c)中的算法复杂度为$O(m\log{\log{n} })$。并给出一种算法， 使得对于任意$m$，都能达到$O(m\log{\log{n} })$</h4><script type="math/tex;mode=display">O(m+\dfrac {m}{\log{n} }\log{n}+n\log{n})=O(2m+n\log{n})\leq O\left(2m+m\right)=O(3m)=O(m)<O(m\log{\log{n} })</script><p>得证</p><hr><p><a href="/media/algo2_sol.pdf">Solution</a></p>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最小生成树</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析 作业1</title>
    <url>/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A1/</url>
    <content><![CDATA[<p>第一周作业</p><a id="more"></a><h3 id="1-T-n-T-left-frac34n-right-n"><a href="#1-T-n-T-left-frac34n-right-n" class="headerlink" title="1. $T(n) = T\left(\frac34n\right) + n$"></a>1. $T(n) = T\left(\frac34n\right) + n$</h3><script type="math/tex;mode=display">{large}
\large
\begin{align*}
&\text{推测递归式的解为 }T(n) = O\left(n\right), 假设解的形式是T(n) = a'n + n = an\\
&代入递归式得\ an = \frac34an + n\quad\Rightarrow a=4\\
\therefore\ &T(n) = 4n\\
\end{align*}</script><h3 id="2-T-n-sqrt-n-cdot-T-sqrt-n-n"><a href="#2-T-n-sqrt-n-cdot-T-sqrt-n-n" class="headerlink" title="2. $T(n) = \sqrt{n} \cdot T(\sqrt{n}) + n$"></a>2. $T(n) = \sqrt{n} \cdot T(\sqrt{n}) + n$</h3><script type="math/tex;mode=display">\large
\begin{align*}
T(n) &= \sqrt{n} \cdot T(\sqrt{n}) + n\\
&=n^{\frac12}\cdot n^{\left(\frac12\right)^2}\cdot T\left(n^{\left(\frac12\right)^2}\right)+ \left(n+n^{\frac12}\cdot n^{\frac12} \right)\\
&=n^{\frac12}\cdot n^{\left(\frac12\right)^2}\cdot n^{\left(\frac12\right)^3} \cdot T\left(n^{\left(\frac12\right)^3}\right)+ \left(n + n^{\frac12}\cdot n^{\frac12} + n^{\frac12}\cdot n^{\left(\frac12\right)^2}\cdot n^{\left(\frac12\right)^2} \right)\\
&= \cdots\\
&= n^{\Large\sum_{i=1}^{L}{\left(\frac12\right)^i} }\cdot T(1) + \sum\limits_{i=1}^{L}{n^{\Large\left(\sum_{j=1}^{i}{\left(\frac12\right)^j}\right)+\left(\frac12\right)^i} }, L=\log_2{n}\\
&= n^{1-2^{-L} }\cdot T(1) + \sum\limits_{i=1}^{L}{n^{1-2^{-i}+2^{-i} } }, L=\log_2{n}\\
&= n^{1-\frac1n}\cdot T(1) + n\log_2{n}
\end{align*}</script><h3 id="3-T-n-frac14-T-left-frac14-n-right-frac34-T-left-frac34-n-right-1"><a href="#3-T-n-frac14-T-left-frac14-n-right-frac34-T-left-frac34-n-right-1" class="headerlink" title="3. $T(n) = \frac14 T\left(\frac14 n\right) + \frac34 T\left(\frac34 n\right) + 1$"></a>3. $T(n) = \frac14 T\left(\frac14 n\right) + \frac34 T\left(\frac34 n\right) + 1$</h3><script type="math/tex;mode=display">\begin{align*}
&\frac14 T\left(\frac14 n\right) + \frac34 T\left(\frac14 n\right) + 1 \leq T(n) \leq \frac14 T\left(\frac34 n\right) + \frac34 T\left(\frac34 n\right) + 1\\
\large{即}\normalsize&T\left(\frac14 n\right) + 1 \leq T(n) \leq T\left(\frac34 n\right) + 1\\
&T(n) \geq T\left(\frac14 n\right) + 1 = T(1) + \log_4{n} = \Omega\left(\log{n}\right)\\
&T(n) \leq T\left(\frac34 n\right) + 1 = T(1) + \log_{\frac43}{n} = O\left(\log{n}\right)\\
\therefore\ & T(n) = \Theta\left(\log{n}\right)
\end{align*}</script><h3 id="4-T-n-T-frac12n-T-frac13n-T-frac16n-n-log-n"><a href="#4-T-n-T-frac12n-T-frac13n-T-frac16n-n-log-n" class="headerlink" title="4. $T(n) = T(\frac12n)+T(\frac13n)+T(\frac16n)+n\log{n}$"></a>4. $T(n) = T(\frac12n)+T(\frac13n)+T(\frac16n)+n\log{n}$</h3><script type="math/tex;mode=display">\begin{align*}
&\frac{1}{2^\rho}+\frac{1}{3^\rho}+\frac{1}{6^\rho}=1\Rightarrow \rho=1\\
&\int_1^n{\frac{f\left(u\right)}{u^{\rho+1} } }\dd{u}=\int_1^n{\frac{\log{u} }{u} }\dd{u}=\frac{1}{\ln{2} }\int_1^n{\ln{u} }\dd{\left(\ln u\right)}=\frac{\ln^2{n} }{2\ln{2} }\\
\therefore\ &T(n)=\Theta\left(n^\rho\left(1+\int_1^n{\frac{f\left(u\right)}{u^{\rho+1} } }\dd{u}\right)\right)=\Theta\left(n+\frac{n\ln^2{n} }{2\ln2}\right)=\Theta(n\ln^2{n})\\
\end{align*}</script><h3 id="5-T-n-3T-frac13n-3T-frac23n-n-2"><a href="#5-T-n-3T-frac13n-3T-frac23n-n-2" class="headerlink" title="5. $T(n)=3T(\frac13n)+3T(\frac23n)+n^2$"></a>5. $T(n)=3T(\frac13n)+3T(\frac23n)+n^2$</h3><script type="math/tex;mode=display">\begin{align*}
&3\cdot\left(\frac{1}{3}\right)^\rho+3\cdot\left(\frac{2}{3}\right)^\rho=1 \Rightarrow \rho=3\\
&\int_1^n{\frac{f\left(u\right)}{u^{\rho+1} } }\dd{u}=\int_1^n{\frac{1}{u^2} }\dd{u}=1-\frac{1}{n}\\
\therefore\ &T(n)=\Theta\left(n^\rho\left(1+\int_1^n{\frac{f\left(u\right)}{u^{\rho+1} } }\dd{u}\right)\right)=\Theta\left(2n^3-n^2\right)=\Theta(n^3)\\
\end{align*}</script><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><script type="math/tex;mode=display">\begin{align*}
\large苹果:&\quad (1+x)\cdot(1+x)=(1+x)^2\\
\large香蕉:&\quad 1+x+x^2+x^3\\
\large无花果:&\quad 1+x^6+x^{12}+x^{18}+\cdots=\frac{1}{1-x^6}\\
\large芒果:&\quad 1+x^2+x^4\\
\large桃子:&\quad1+x^4+x^8+x^{12}+\cdots=\frac{1}{1-x^4}\\
G(x)=&(1+x)^2\cdot(1+x+x^2+x^3)\cdot\frac{1}{1-x^6}\cdot(1+x^2+x^4)\cdot\frac{1}{1-x^4}\\
=&(1+x)^2\cdot \frac{1-x^4}{1-x}\cdot \frac{1}{1-x^6}\cdot \frac{1-x^6}{1-x^2}\cdot \frac{1}{1-x^4}\\
=&\frac{1+x}{\left(1-x\right)^2}\\
=&(1+x)\cdot\left(1-x\right)^{-2}\\
=&(1+x)\cdot \sum\limits_{n=0}^{+\infty}{-2\choose n}(-x)^n\\
=&(1+x)\cdot \sum\limits_{n=0}^{+\infty}{\frac{(-2)\cdot(-2-1)\cdots\left(-2-\left(n-1\right)\right)}{n!} }(-x)^n\\
=&(1+x)\cdot \sum\limits_{n=0}^{+\infty}{\frac{(n+1)\cdot n\cdots2\cdot1}{n!} }\left(-1\right)^n (-x)^n\\
=&(1+x)\cdot \sum\limits_{n=0}^{+\infty}(n+1) x^n\\
=& 1+\sum\limits_{n=1}^{+\infty}(n+1) x^n+\sum\limits_{n=1}^{+\infty}n x^n\\
=& 1+\sum\limits_{n=1}^{+\infty}(2n+1) x^n\\
=& \sum\limits_{n=0}^{+\infty}(2n+1) x^n\\
\therefore\ \ &x^n\large项的系数为\normalsize 2n+1
\end{align*}</script>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析 作业56</title>
    <url>/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A6/</url>
    <content><![CDATA[<p>第六周作业</p><a id="more"></a><h3 id="1-势能分析法说明删除时数组大小-n-leq-frac14-c-才将数组容量缩小为原来的-frac12-并把数据复制过去的均摊复杂度也为-O-1"><a href="#1-势能分析法说明删除时数组大小-n-leq-frac14-c-才将数组容量缩小为原来的-frac12-并把数据复制过去的均摊复杂度也为-O-1" class="headerlink" title="1. 势能分析法说明删除时数组大小$n \leq \frac14 c$才将数组容量缩小为原来的$\frac12$并把数据复制过去的均摊复杂度也为$O(1)$"></a>1. 势能分析法说明删除时数组大小$n \leq \frac14 c$才将数组容量缩小为原来的$\frac12$并把数据复制过去的均摊复杂度也为$O(1)$</h3><p>定义$\Phi(n,c)=\begin{cases}2n-c &amp; n\geq\frac{1}{2}c\\ \frac{1}{2}c-n&amp;n&lt;\frac{1}{2}c\end{cases}$</p><p>当$n&gt;\frac{1}{4}c$时，不会缩容，开销为$1$，$\Delta\Phi=(2(n-1)-c) - (2n-c)=-2$或$=(\frac12 c-(n-1))-(\frac12c-n)=1$，$c_i=1+\Delta\Phi=O(1)$</p><p>当$n\leq\frac{1}{4}c$时，缩容的拷贝开销为$n$，$\Delta\Phi=\left(\frac12\cdot \frac12c-\left( n-1 \right) \right) - \left(\frac12c-n\right)=1-\frac14c$，$c_i=n+\Delta\Phi\leq1=O(1)$</p><p>得证</p><h3 id="2-用势能分析法说明2-3树插入和删除操作的时间复杂度都是平摊-O-log-n"><a href="#2-用势能分析法说明2-3树插入和删除操作的时间复杂度都是平摊-O-log-n" class="headerlink" title="2. 用势能分析法说明2-3树插入和删除操作的时间复杂度都是平摊$O(\log{n})$"></a>2. 用势能分析法说明2-3树插入和删除操作的时间复杂度都是平摊$O(\log{n})$</h3><p>定义$\Phi=h$</p><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>当不需要分裂节点时，只需要$O(\log{n})$地查找节点位置，$O(1)$插入即可，$\Delta\Phi=0$，$c_i=O(\log{n})$</p><p>需要分裂节点时，</p><p>​ 父节点为2节点时，直接把子节点中间大小的元素与父节点合并，最大最小元素变成父节点的另外两个子节点。需要$O(\log{n})$查找节点位置，$O(1)$插入，$\Delta\Phi=0$，$c_i=O(\log{n})$。</p><p>​ 父节点为3节点时，将子节点子节点中间大小的元素与父节点合并，最大最小元素变成父节点的另外两个子节点。这样父节点有3个元素、4个子节点，需要继续向上传进行分裂，四个子节点两个归左边两个归右边。需要$O(\log{n})$查找节点位置，$O(1)$插入，$\Delta\Phi=0$，$c_i=O(\log{n})$。</p><p>​ 没有父节点时，需要新建一个节点用来存放子节点的中间值。需要$O(\log{n})$查找节点位置，$O(1)$插入，$\Delta\Phi=1$，$c_i=1+O(\log{n})=O(\log{n})$。</p><p>所以均摊的时间复杂度为$O(\log{n})$</p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>删除的元素不为叶子时，找前驱，和父节点元素交换，然后删除。查找开销$O(\log{n})$，$\Delta\Phi=0$，$c_i=O(\log{n})$</p><p>删除的元素位于3节点的叶子时，直接删除即可。查找开销$O(\log{n})$，$\Delta\Phi=0$，$c_i=O(\log{n})$</p><p>删除的元素位于2节点的叶子时，</p><p>​ 若兄弟节点为3节点，那么删除位置换成它的前驱/后继（原来在父节点上），再把换下来元素的前驱/后继放在父节点上。查找开销$O(\log{n})$，$\Delta\Phi=0$，$c_i=O(\log{n})$</p><p>​ 若兄弟节点为2节点、父节点为3节点，那么向父节点借，并与兄弟节点结合，最后父节点从 3-节点变成了 2-节点。查找开销$O(\log{n})$，$\Delta\Phi=0$，$c_i=O(\log{n})$</p><p>​ 若父节点和兄弟节点均为2节点，那么首先让父节点和兄弟节点合并。此时原来的父节点内值为空，为填补这个空节点，我们要再对父节点执行一次删除操作（仅为调整结构）。查找开销$O(\log{n})$，$\Delta\Phi=0$，$c_i=O(\log{n})$</p><p>所以均摊的时间复杂度为$O(\log{n})$</p><h3 id="3-设计一个队列，支持入队enqueue，出队dequeue和查询最小值find-min，每个操作都是平摊-O-1-，并用势能分析法分析复杂度。"><a href="#3-设计一个队列，支持入队enqueue，出队dequeue和查询最小值find-min，每个操作都是平摊-O-1-，并用势能分析法分析复杂度。" class="headerlink" title="3. 设计一个队列，支持入队enqueue，出队dequeue和查询最小值find_min，每个操作都是平摊$O(1)$，并用势能分析法分析复杂度。"></a>3. 设计一个队列，支持入队<code>enqueue</code>，出队<code>dequeue</code>和查询最小值<code>find_min</code>，每个操作都是平摊$O(1)$，并用势能分析法分析复杂度。</h3><p>两个队列，<code>main</code>和<code>min</code>，<code>main</code>就是正常队列，<code>min</code>递增，用来存可能的最小元素</p><p>定义势能函数$\Phi=main.size()$</p><h5 id="入队-x"><a href="#入队-x" class="headerlink" title="入队$x$"></a>入队$x$</h5><p>往<code>main</code>里面push，如果$x$比<code>min</code>队列的头还小，那就一直把比$x$还小的值pop出去（它们不会再进入<code>main</code>队列了），再将$x$ push进<code>min</code>队列。</p><p>$\Delta\Phi=-\Delta(main.size())$，$c_i=1+\Delta(main.size())+\Delta\Phi=1=O(1)$</p><h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><p>将main的队首pop掉，如果出队的元素等于 <code>min</code> 的第一个元素，则也将 <code>min</code> 的第一个元素出队。</p><p>$\Delta\Phi=-1$，$c_i=1+1+\Delta\Phi=1=O(1)$</p><h5 id="查找min"><a href="#查找min" class="headerlink" title="查找min"></a>查找min</h5><p><code>min</code>队列的队头就是，$\Delta\Phi=0$，$c_i=O(1)$</p><h3 id="4-设计一个数据结构，动态维护一个大小-m-为的集合-S-，支持插入一个元素insert，和删除最小的-lceil-frac-n-2-rceil-个元素remove-bottom-half，每个操作都是平摊-O-1-，并用势能分析法分析复杂度。"><a href="#4-设计一个数据结构，动态维护一个大小-m-为的集合-S-，支持插入一个元素insert，和删除最小的-lceil-frac-n-2-rceil-个元素remove-bottom-half，每个操作都是平摊-O-1-，并用势能分析法分析复杂度。" class="headerlink" title="4. 设计一个数据结构，动态维护一个大小$m$为的集合$S$，支持插入一个元素insert，和删除最小的$\lceil \frac{n}2\rceil$个元素remove_bottom_half，每个操作都是平摊$O(1)$，并用势能分析法分析复杂度。"></a>4. 设计一个数据结构，动态维护一个大小$m$为的集合$S$，支持插入一个元素<code>insert</code>，和删除最小的$\lceil \frac{n}2\rceil$个元素<code>remove_bottom_half</code>，每个操作都是平摊$O(1)$，并用势能分析法分析复杂度。</h3><p>动态数组中存储元素的值。定义势能函数$\Phi=6n$</p><h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><p>添加到数组末尾里即可，$\Delta\Phi=4$，$c_i=1+\Delta\Phi=7=O(1)$</p><h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>$O(n)$扫描整个数组的有效元素出来，$O(n)$计算出中位数（<a href="https://blog.csdn.net/qiaoxinwei/article/details/108976111" target="_blank" rel="noopener">找第k小</a>），再$O(n)$扫描所有小于中位数的值，打上删除标记即可。不过需要定期缩容。</p><p>$\Delta\Phi=6(n-\lceil \frac n2\rceil)-6n=-3n$，$c_i=3n+\Delta\Phi=0=O(1)$</p><h3 id="5-n-个数排成一行，其中第-i-个是整数-a-i-，初始均为-0-。-执行-m-次assign-l-r-x-操作。每次对于所有-l-leq-i-leq-r-，将-a-i-赋值为-x-，每次操作的消耗定义为区间里不同-a-i-的个数。"><a href="#5-n-个数排成一行，其中第-i-个是整数-a-i-，初始均为-0-。-执行-m-次assign-l-r-x-操作。每次对于所有-l-leq-i-leq-r-，将-a-i-赋值为-x-，每次操作的消耗定义为区间里不同-a-i-的个数。" class="headerlink" title="5. $n$个数排成一行，其中第$i$个是整数$a_i$，初始均为$0$。 执行$m$次assign(l, r, x)操作。每次对于所有$l\leq i\leq r$，将$a_i$赋值为$x$，每次操作的消耗定义为区间里不同$a_i$的个数。"></a>5. $n$个数排成一行，其中第$i$个是整数$a_i$，初始均为$0$。 执行$m$次<code>assign(l, r, x)</code>操作。每次对于所有$l\leq i\leq r$，将$a_i$赋值为$x$，每次操作的消耗定义为区间里不同$a_i$的个数。</h3><h5 id="1-使用势能分析法说明-m-次操作的消耗最多是-3m-。"><a href="#1-使用势能分析法说明-m-次操作的消耗最多是-3m-。" class="headerlink" title="(1) 使用势能分析法说明$m$次操作的消耗最多是$3m$。"></a>(1) 使用势能分析法说明$m$次操作的消耗最多是$3m$。</h5><p>定义势能函数$\Phi=\text{序列内相邻两元素不相同的个数}$，如$a=[1,2,3,2,2,1]$则$\Phi=4$</p><p>每次<code>assign</code>操作时，会将区间内设为同一个值（区间内相邻元素不同的个数减少或不变），可能在区间边界新增和相邻元素不同的个数，但至多为$2$，因此$\Delta\Phi\leq2$</p><p>令$k_i\geq1$表示单次操作时区间内不同元素的个数，显然在操作结束之后这$k_i$个不同的元素就变成同一个了，也就是影响$\Delta\Phi$的$r-l+2$（暂不考虑数列边界）个数中有$r-l$个数在操作后变为同一个数了，至多新增$2$个不同的数（边界上）。所以$\Delta\Phi+k_i\leq3$，那么$c_i=k_i+\Delta\Phi\leq3$</p><p>$m$次操作的总代价为$\sum\limits_{i=1}^{m}{c_i}\leq3m$</p><h5 id="2-说明任意小于-3-的常数都不成立。"><a href="#2-说明任意小于-3-的常数都不成立。" class="headerlink" title="(2) 说明任意小于$3$的常数都不成立。"></a>(2) 说明任意小于$3$的常数都不成立。</h5><p>最坏情况为$3$且能取到，所以不能比$3$还小。</p>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>均摊分析</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析 作业3</title>
    <url>/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A3/</url>
    <content><![CDATA[<p>第三周作业</p><a id="more"></a><h3 id="1-定义witness为运行Bellman-Ford算法n轮时距离依然减少的点。"><a href="#1-定义witness为运行Bellman-Ford算法n轮时距离依然减少的点。" class="headerlink" title="1. 定义witness为运行Bellman-Ford算法n轮时距离依然减少的点。"></a>1. 定义witness为运行Bellman-Ford算法n轮时距离依然减少的点。</h3><h4 id="a-证明：每一个负环上至少存在一个witness"><a href="#a-证明：每一个负环上至少存在一个witness" class="headerlink" title="(a) 证明：每一个负环上至少存在一个witness"></a>(a) 证明：每一个负环上至少存在一个witness</h4><p>设某个负环上有$l_i(l_i\leq n)$个点，显然，至多$l_i$轮就可以将这个负环上的距离更新一遍。</p><p>当$l_i=n$时，这个负环上的witness就是最后一个更新的点；当$l_i&lt;n$时，在剩余的轮里，一定可以从这个点出发，更新负环内的其它点，因此环上一定存在一个witness。</p><h4 id="b-构造一张图使得至少存在一个witness不在负环上"><a href="#b-构造一张图使得至少存在一个witness不在负环上" class="headerlink" title="(b) 构造一张图使得至少存在一个witness不在负环上"></a>(b) 构造一张图使得至少存在一个witness不在负环上</h4><p>以点1为源点计算最短路，按边1、2、3、4、5的顺序更新。</p><p>第一轮：$d_1=0, d_2=-1,d_3=d_4=\infty,d_5=1$</p><p>第四轮：$d_1=-4, d_2=-1,d_3=-2，d_4=-3,d_5=1$</p><p>第五轮：$d_1=-4, d_2=-5,d_3=-2，d_4=-3,d_5=-3$，witeness为点2和点5，其中点5不在负环上。</p><p><img data-src="/images/algo3_1.png" style="zoom:50%"></p><h3 id="2-DAG中的单源最短路可以在-O-V-E-的时间内求解。求解步骤为：1、求出图的拓扑序；2、根据拓扑序对每个节点进行松弛。"><a href="#2-DAG中的单源最短路可以在-O-V-E-的时间内求解。求解步骤为：1、求出图的拓扑序；2、根据拓扑序对每个节点进行松弛。" class="headerlink" title="2. DAG中的单源最短路可以在$O(|V|+|E|)$的时间内求解。求解步骤为：1、求出图的拓扑序；2、根据拓扑序对每个节点进行松弛。"></a>2. DAG中的单源最短路可以在$O(|V|+|E|)$的时间内求解。求解步骤为：1、求出图的拓扑序；2、根据拓扑序对每个节点进行松弛。</h3><h4 id="a-写出算法的伪代码"><a href="#a-写出算法的伪代码" class="headerlink" title="(a) 写出算法的伪代码"></a>(a) 写出算法的伪代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SSSP_DAG</span><span class="params">(G, s)</span>:</span></span><br><span class="line">    dis = [infty <span class="keyword">for</span> _ <span class="keyword">in</span> G.V]</span><br><span class="line">    dis[s] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    topo = topo_sort(G)</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> topo:</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> G.E[u]:</span><br><span class="line">            <span class="keyword">if</span> dis[u] + e.w &lt; dis[e.to]:</span><br><span class="line">                dis[e.to] = dis[u] + e.w</span><br><span class="line">    <span class="keyword">return</span> dis</span><br></pre></td></tr></table></figure><h4 id="b-说明为什么按照拓扑序的松弛得到的结果是正确的"><a href="#b-说明为什么按照拓扑序的松弛得到的结果是正确的" class="headerlink" title="(b) 说明为什么按照拓扑序的松弛得到的结果是正确的"></a>(b) 说明为什么按照拓扑序的松弛得到的结果是正确的</h4><p>对于拓扑序排在s点前的点，根据DAG的性质，s点无法到达这些点，因此这些点的<code>dis</code>为正无穷是正确的。</p><p>对于拓扑序排在s点后的点，根据拓扑排序的性质，一定是拓扑序在前面的点处理完毕后才可以处理后边的点。这样就可以保证，前驱节点在松弛当前节点的时候就已经正确计算完毕了，所以结果是正确的。</p><h3 id="3-Dijkstra算法只适用于求边权非负的图的最短路，如果存在负权边则算法的正确性不能保证。但是，假如运行Dijkstra多次呢？假设一张图中有-k-1-条负权边，但不存在负环，运行-k-次Dijkstra算法，每次运行结束后，从源点向每个节点连一条长度为-d-s-u-的边，证明这样正确的求出源点到每个点的距离。"><a href="#3-Dijkstra算法只适用于求边权非负的图的最短路，如果存在负权边则算法的正确性不能保证。但是，假如运行Dijkstra多次呢？假设一张图中有-k-1-条负权边，但不存在负环，运行-k-次Dijkstra算法，每次运行结束后，从源点向每个节点连一条长度为-d-s-u-的边，证明这样正确的求出源点到每个点的距离。" class="headerlink" title="3. Dijkstra算法只适用于求边权非负的图的最短路，如果存在负权边则算法的正确性不能保证。但是，假如运行Dijkstra多次呢？假设一张图中有$k-1$条负权边，但不存在负环，运行$k$次Dijkstra算法，每次运行结束后，从源点向每个节点连一条长度为$d(s,u)$的边，证明这样正确的求出源点到每个点的距离。"></a>3. Dijkstra算法只适用于求边权非负的图的最短路，如果存在负权边则算法的正确性不能保证。但是，假如运行Dijkstra多次呢？假设一张图中有$k-1$条负权边，但不存在负环，运行$k$次Dijkstra算法，每次运行结束后，从源点向每个节点连一条长度为$d(s,u)$的边，证明这样正确的求出源点到每个点的距离。</h3><p>Dijkstra不能处理负边的原因，在于不能对已确定最短路径的点进行二次更新（<code>vis</code>这个数组）。</p><p>将上一轮的最短路结果连边，进行新的一轮，相当于在已确定最短路径的点进行二次更新，这样就可以保证正确求出最短路。</p><p>运行$k$次可以保证因$k-1$条负权边引起的二次修改都能被满足。</p><h3 id="4-无向图中x到y的最小瓶颈路是这样的一类简单路径，满足这条路径上的最大的边权在所有x到y的简单路径中最小。"><a href="#4-无向图中x到y的最小瓶颈路是这样的一类简单路径，满足这条路径上的最大的边权在所有x到y的简单路径中最小。" class="headerlink" title="4. 无向图中x到y的最小瓶颈路是这样的一类简单路径，满足这条路径上的最大的边权在所有x到y的简单路径中最小。"></a>4. 无向图中x到y的最小瓶颈路是这样的一类简单路径，满足这条路径上的最大的边权在所有x到y的简单路径中最小。</h3><h4 id="a-证明：任意一棵最小生成树上x到y的路径就是原图中x到y的最小瓶颈路"><a href="#a-证明：任意一棵最小生成树上x到y的路径就是原图中x到y的最小瓶颈路" class="headerlink" title="(a) 证明：任意一棵最小生成树上x到y的路径就是原图中x到y的最小瓶颈路"></a>(a) 证明：任意一棵最小生成树上x到y的路径就是原图中x到y的最小瓶颈路</h4><p>反证：假设存在一条$x$到$y$的最小瓶颈路，路径$R’$上最大边权$w(e’)$比最小生成树上的路径$w(e)$还小。那么我们可以删去树上$e’$这条边，用最小瓶颈路上的边连接这两个连通块，新树的边权之和一定比原来还小，与最小生成树矛盾。</p><h4 id="b-最小生成树上x到y的路径一定是原图中x到y的最小瓶颈路，但是并不是x到y的所有最小瓶颈路都在某棵最小生成树上，构造一张图使得x到y的一条最小瓶颈路不在任何一棵最小生成树上。"><a href="#b-最小生成树上x到y的路径一定是原图中x到y的最小瓶颈路，但是并不是x到y的所有最小瓶颈路都在某棵最小生成树上，构造一张图使得x到y的一条最小瓶颈路不在任何一棵最小生成树上。" class="headerlink" title="(b) 最小生成树上x到y的路径一定是原图中x到y的最小瓶颈路，但是并不是x到y的所有最小瓶颈路都在某棵最小生成树上，构造一张图使得x到y的一条最小瓶颈路不在任何一棵最小生成树上。"></a>(b) 最小生成树上x到y的路径一定是原图中x到y的最小瓶颈路，但是并不是x到y的所有最小瓶颈路都在某棵最小生成树上，构造一张图使得x到y的一条最小瓶颈路不在任何一棵最小生成树上。</h4><p>路径1-2-3-4和1-3-4都是最小瓶颈路，但1-2这条边一定不会出现在最小生成树上。</p><p><img data-src="https://oi-wiki.org/graph/images/mst5.png" style="zoom:50%"></p><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><h4 id="a-说明对于一般的图，如何用Bellman-Ford算法使用的-O-nm-时间判断图中是否存在负环。（不一定所有点都从源点可达）"><a href="#a-说明对于一般的图，如何用Bellman-Ford算法使用的-O-nm-时间判断图中是否存在负环。（不一定所有点都从源点可达）" class="headerlink" title="(a) 说明对于一般的图，如何用Bellman-Ford算法使用的$O(nm)$时间判断图中是否存在负环。（不一定所有点都从源点可达）"></a>(a) 说明对于一般的图，如何用Bellman-Ford算法使用的$O(nm)$时间判断图中是否存在负环。（不一定所有点都从源点可达）</h4><p>用并查集维护连通块，对每一个连通块运行Bellman-Ford算法进行判断。</p><h4 id="b-假设一张图不存在负环，说明如何用Bellman-Ford算法判断一张图是否存在零环"><a href="#b-假设一张图不存在负环，说明如何用Bellman-Ford算法判断一张图是否存在零环" class="headerlink" title="(b) 假设一张图不存在负环，说明如何用Bellman-Ford算法判断一张图是否存在零环"></a>(b) 假设一张图不存在负环，说明如何用Bellman-Ford算法判断一张图是否存在零环</h4><p>由于没有负环，那么零环一定满足：环上一点到它环中前驱的的最短路（否则就出现负环了），等于前驱到它边权的相反数。</p><p><img data-src="/images/algo3_2.png" style="zoom:50%"></p><p>那么就可以对所有点跑一遍Bellman-Ford最短路，枚举所有有边指向起点且一步相连的点，看最短路和边权相加是否为0即可。</p><p>时间复杂度$O(n^2m)$</p><h4 id="c-求最小权重比率环"><a href="#c-求最小权重比率环" class="headerlink" title="(c) 求最小权重比率环"></a>(c) 求最小权重比率环</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EPS = <span class="number">1e-7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relax</span><span class="params">(dis, <span class="params">(u, v, w)</span>, alpha)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> dis[u] + w - alpha &lt; dis[v]:</span><br><span class="line">        dis[v] = dis[u] + w - alpha</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BellmanFord</span><span class="params">(G, s, mid)</span>:</span></span><br><span class="line">    dis = [infty <span class="keyword">for</span> n <span class="keyword">in</span> G.N]</span><br><span class="line">    dis[s] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> G.N:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> G.V:</span><br><span class="line">            flag |= relax(e, mid)</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">erfen</span><span class="params">(s)</span>:</span></span><br><span class="line">    l = -M</span><br><span class="line">    r = M</span><br><span class="line">    mid = (l + r) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> BellmanFord(G, s, mid) == <span class="literal">True</span>: <span class="comment"># 存在负环</span></span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid</span><br><span class="line">        mid_new = (l + r) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> math.abs(mid_new - mid) &lt; EPS:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        mid = mid_new</span><br><span class="line">    <span class="keyword">return</span> mid</span><br></pre></td></tr></table></figure><hr><p><a href="/media/algo3_sol.pdf">Solution</a></p>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析 作业4</title>
    <url>/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A4/</url>
    <content><![CDATA[<p>第四周作业</p><a id="more"></a><h3 id="1-计算普通FFT算法的数据写入复杂度"><a href="#1-计算普通FFT算法的数据写入复杂度" class="headerlink" title="1. 计算普通FFT算法的数据写入复杂度"></a>1. 计算普通FFT算法的数据写入复杂度</h3><p>设缓存大小为$M$，块大小为$B$，FFT的采样次数为$N$：</p><p>前$\log{\frac{N}{B}}$层，每层Cache Miss为$\frac{N}{B}$，总Cache Miss为$1\cdot\dfrac{N}{B} + 2\cdot\dfrac{\frac{N}{2}}{B} + 4\cdot\dfrac{\frac{N}{4}}{B} +\cdots + 2^{\log{\frac{N}{B}}}\cdot\dfrac{\frac{N}{2^{\log{\frac{N}{B}}}}}{B}=\frac{N}{B}\log{\frac{N}{B}}$</p><p>后$\log{B}$层，每层块大小$&lt;B$，因此每一个小块都是一次Cache Miss，总Cache Miss为$\frac{N}{B}\cdot 2+\frac{N}{B}\cdot 4+\cdots+\frac{N}{B}\cdot B=2N-2\frac{N}{B}\approx 2N$</p><p>所有层的Cache Miss次数为$O(\frac{N}{B}\log{\frac{N}{B}}+N)$</p><h3 id="2-已知向量-w-，-q-v-w-F-1-F-v-times-F-w-，求向量-v"><a href="#2-已知向量-w-，-q-v-w-F-1-F-v-times-F-w-，求向量-v" class="headerlink" title="2. 已知向量$w$，$q=v*w=F^{-1}(F(v)\times F(w))$，求向量$v$"></a>2. 已知向量$w$，$q=v*w=F^{-1}(F(v)\times F(w))$，求向量$v$</h3><p>将$w$和$q$进行傅里叶变换得到$F(w)$和$F(q)$。根据卷积定理，卷积在时域中等于频域中的乘法，即$F(q)=F(w)\times F(v)$，可得$F(v)=\dfrac{F(q)}{F(w)}$，对$F(v)$进行傅里叶逆变换即得向量$v$。</p><h3 id="3-FFT计算多项式减法卷积"><a href="#3-FFT计算多项式减法卷积" class="headerlink" title="3. FFT计算多项式减法卷积"></a>3. FFT计算多项式减法卷积</h3><p>减法卷积相当于把$B=b_0+b_1x+\cdots +b_mx^m$变换成$B’=b_mx^{-m}+\cdots+b_1x^{-1}+b_0$，再计算$C=A\cdot B’$的卷积。</p><p>首先对$A$、$B’$两个多项式进行FFT，得到$F(A)$、$F(B)$，之后将两个结果相乘后进行傅里叶逆变换，得到卷积结果，再逆变换即得多项式$C$。</p><p>不过$A$也需要预处理移位一下，让系数数组的最前一项代表$x^{-m}$项的系数，最终$c_n$其实是结果多项式$C’$系数数组的第$n+m$项（从$0$开始编号）。</p><h3 id="4-求正整数序列有多少连续子序列满足区间和-x"><a href="#4-求正整数序列有多少连续子序列满足区间和-x" class="headerlink" title="4. 求正整数序列有多少连续子序列满足区间和 $=x$"></a>4. 求正整数序列有多少连续子序列满足区间和 $=x$</h3><p>首先计算前缀和$S_m=\sum\limits_{i=1}^{m}{a_i}$，那么求连续区间和$=x$个数就是求满足$S_i-S_{j-1}=x(i\geq j)$的$(i,j)$对个数。那么定义多项式$A=\sum{[S_m=a的次数]x^a}$，使用第三问中方法计算$A$与$A$的减法卷积得到多项式$B$，$B$的$x$次项系数即为子序列数。</p><h3 id="5-FFT解决字符串匹配"><a href="#5-FFT解决字符串匹配" class="headerlink" title="5. FFT解决字符串匹配"></a>5. FFT解决字符串匹配</h3><h4 id="a-给出一个-O-S-log-S-的算法，求出所有-T-在-S-中所有出现的位置。"><a href="#a-给出一个-O-S-log-S-的算法，求出所有-T-在-S-中所有出现的位置。" class="headerlink" title="(a) 给出一个$O(|S|\log{|S|})$的算法，求出所有$T$在$S$中所有出现的位置。"></a>(a) 给出一个$O(|S|\log{|S|})$的算法，求出所有$T$在$S$中所有出现的位置。</h4><p>定义多项式$A=\sum\limits_{i=0}^{|S|-1}\text{ascii}(S_i)x^i$，$B=\sum\limits_{i=0}^{|T|-1}\text{ascii}(T_i)x^i$，$C=\sum\limits_{i=0}^{|S|-|T|}{\left( \sum\limits_{j=0}^{|T|-1}{\left( a_{i+j}-b_{j} \right)^2} x^i\right)}$，显然当$c_i=0$时，代表在第$i$位字符串匹配上了。</p><p>看一下如何计算$c_n$：$c_i = \sum\limits_{j=0}^{|T|-1}{\left( a_{i+j}-b_{j} \right)^2}= \sum\limits_{j=0}^{|T|-1}{a_{i+j}^2} + \sum\limits_{j=0}^{|T|-1}{b_{j}^2} - 2\sum\limits_{j=0}^{|T|-1}{a_{i+j}b_j}$</p><p>其中$\sum\limits_{j=0}^{|T|-1}{a_{i+j}^2}$项可以用前缀和预处理，$\sum\limits_{j=0}^{|T|-1}{b_{j}^2}$是定值，使用时可$O(1)$得到，剩下一项中的$\sum\limits_{j=0}^{|T|-1}{a_{i+j}b_j}$需要再处理一下以方便计算。</p><p>把$T$串翻转，反转后字符串对应的多项式$R=\sum\limits_{i=0}^{|T|-1}{r_ix^i},\quad r_i=b_{|T|-1-i}$。那么最后一项变成$p_i=\sum\limits_{j=0}^{|T|-1}{a_{i+j}r_{|T|-1-j}}=\sum\limits_{\substack{s+t=i+|T|-1\\ i\leq s}}{a_sr_t}$，符合卷积形式，可以使用FFT进行计算。</p><p>就这样计算出$C$后，遍历$C$的系数，为0处即为匹配上的位置。</p><h4 id="b-存在通配符（可匹配任何字符）的字符串匹配"><a href="#b-存在通配符（可匹配任何字符）的字符串匹配" class="headerlink" title="(b) 存在通配符（可匹配任何字符）的字符串匹配"></a>(b) 存在通配符（可匹配任何字符）的字符串匹配</h4><p>由于通配符一定能匹配，所以在通配符那一位的$c_i$一定是$0$，所以修改多项式$A$、$B$的系数定义为$\begin{cases}0&amp;S_i为通配符\\\text{ascii}(S_i)&amp;其他情况\end{cases}$，$c_i=\sum\limits_{j=0}^{|T|-1}{\left( a_{i+j}-b_{j} \right)^2a_{i+j}b_j}$</p><p>同样反转$T$串，这样$c_i=\sum\limits_{j=0}^{|T|-1}{(a^3)_{i+j}r_{|T|-1-j}}+\sum\limits_{j=0}^{|T|-1}{a_{i+j}(r^3)_{|T|-1-j}}-2\sum\limits_{j=0}^{|T|-1}{(a^2)_{i+j}(r^2)_{|T|-1-j}}$。显然，这是$3$个卷积，进行$3$次FFT即可解决问题。</p><h3 id="6-Cache-Oblivious-FFT算法"><a href="#6-Cache-Oblivious-FFT算法" class="headerlink" title="6. Cache-Oblivious FFT算法"></a>6. Cache-Oblivious FFT算法</h3><h4 id="a-Cache-Oblivious-矩阵转置算法（数据搬运复杂度-O-frac-nm-B-）"><a href="#a-Cache-Oblivious-矩阵转置算法（数据搬运复杂度-O-frac-nm-B-）" class="headerlink" title="(a) Cache-Oblivious 矩阵转置算法（数据搬运复杂度$O(\frac{nm}{B})$）"></a>(a) Cache-Oblivious 矩阵转置算法（数据搬运复杂度$O(\frac{nm}{B})$）</h4><p>将矩阵从中间分成四部分，递归地转置，大概是这样子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trans</span><span class="params">(&amp;src[N][M], &amp;dst[M][N], s_x, s_y, d_x, d_y, len_n, len_m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">and</span> m == <span class="number">1</span>:</span><br><span class="line">        dst[d_x][d_y] = src[s_x][s_y]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    mid_n = len_n // <span class="number">2</span>; mid_m = len_m // <span class="number">2</span></span><br><span class="line">    trans(src, dst, s_x        , s_y        , d_x        , d_y        , mid_n        , mid_m        ) //左上</span><br><span class="line">    trans(src, dst, s_x        , s_y + mid_m, d_x + mid_m, d_y        , mid_n        , len_m - mid_m) //右上</span><br><span class="line">    trans(src, dst, s_x + mid_n, s_y        , d_x        , d_y + mid_n, len_n - mid_n, mid_m        ) //左下</span><br><span class="line">    trans(src, dst, s_x + mid_n, s_y + mid_m, d_x + mid_m, d_y + mid_n, len_n - mid_n, len_m - mid_m) //右下</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>这样会尽量在缓存已有的矩阵部分中进行交换。</p><h4 id="b-在Cache-Oblivious-FFT中，能否将两个矩阵-X-、-Y-都设定成-N-1-times-N-2-大小以避免转置"><a href="#b-在Cache-Oblivious-FFT中，能否将两个矩阵-X-、-Y-都设定成-N-1-times-N-2-大小以避免转置" class="headerlink" title="(b) 在Cache-Oblivious FFT中，能否将两个矩阵$X$、$Y$都设定成$N_1\times N_2$大小以避免转置"></a>(b) 在Cache-Oblivious FFT中，能否将两个矩阵$X$、$Y$都设定成$N_1\times N_2$大小以避免转置</h4><p>不可行。因为转置是为了让维度匹配而非单纯为了能计算，即使$N_1=N_2$也需要转置。</p><h4 id="c-可否交换求和的顺序来减少转置次数"><a href="#c-可否交换求和的顺序来减少转置次数" class="headerlink" title="(c) 可否交换求和的顺序来减少转置次数"></a>(c) 可否交换求和的顺序来减少转置次数</h4><p>减少了转置开销，但有可能造成更多的Cache Miss，导致得不偿失。</p><p><a href="/media/algo4_sol.pdf">Solution</a></p>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>靠前冲刺Day5</title>
    <url>/%E9%9D%A0%E5%89%8D%E5%86%B2%E5%88%BADay5/</url>
    <content><![CDATA[<h2 id="qbxt靠前冲刺Day5"><a href="#qbxt靠前冲刺Day5" class="headerlink" title="qbxt靠前冲刺Day5"></a>qbxt靠前冲刺Day5</h2><a id="more"></a><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><h4 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h4><p>现在有四种颜色的东西，各有$n_1,n_2,n_3,n_4$个。你需要把他们放到一排里面，并且保证相邻的东西颜色不同，问方案数。</p><h5 id="Subtask-1-n-1-n-2-n-3-n-4-leq10"><a href="#Subtask-1-n-1-n-2-n-3-n-4-leq10" class="headerlink" title="Subtask 1 $n_1+n_2+n_3+n_4\leq10$"></a>Subtask 1 $n_1+n_2+n_3+n_4\leq10$</h5><p>爆搜</p><h5 id="Subtask-2-n-1-0-n-2-n-3-n-4-leq50"><a href="#Subtask-2-n-1-0-n-2-n-3-n-4-leq50" class="headerlink" title="Subtask 2 $n_1=0,n_2,n_3,n_4\leq50$"></a>Subtask 2 $n_1=0,n_2,n_3,n_4\leq50$</h5><p>令$dp_{i,j,l,k}$表示第二、三、四种球已经填了$i,j,l$种，并且以第$k$种球结尾的方案数</p><p>那么可以推出，$dp_{1,0,0,1}=dp_{0,1,0,2}=dp_{0,0,1,3}=0$</p><p>转移看代码得了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> solve2 &#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">60</span>][<span class="number">60</span>][<span class="number">60</span>][<span class="number">5</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n[<span class="number">2</span>]; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n[<span class="number">3</span>]; ++j)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= n[<span class="number">4</span>]; ++l)</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">3</span>; ++k) &#123;</span><br><span class="line">						<span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">							dp[i][j + <span class="number">1</span>][l][<span class="number">2</span>] = (dp[i][j + <span class="number">1</span>][l][<span class="number">2</span>] + dp[i][j][l][k]) % mod,</span><br><span class="line">							dp[i][j][l + <span class="number">1</span>][<span class="number">3</span>] = (dp[i][j][l + <span class="number">1</span>][<span class="number">3</span>] + dp[i][j][l][k]) % mod;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">2</span>)</span><br><span class="line">							dp[i + <span class="number">1</span>][j][l][<span class="number">1</span>] = (dp[i + <span class="number">1</span>][j][l][<span class="number">1</span>] + dp[i][j][l][k]) % mod,</span><br><span class="line">							dp[i][j][l + <span class="number">1</span>][<span class="number">3</span>] = (dp[i][j][l + <span class="number">1</span>][<span class="number">3</span>] + dp[i][j][l][k]) % mod;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">							dp[i][j + <span class="number">1</span>][l][<span class="number">2</span>] = (dp[i][j + <span class="number">1</span>][l][<span class="number">2</span>] + dp[i][j][l][k]) % mod,</span><br><span class="line">							dp[i + <span class="number">1</span>][j][l][<span class="number">1</span>] = (dp[i + <span class="number">1</span>][j][l][<span class="number">1</span>] + dp[i][j][l][k]) % mod;</span><br><span class="line">					&#125;</span><br><span class="line">		ans = (dp[n[<span class="number">2</span>]][n[<span class="number">3</span>]][n[<span class="number">4</span>]][<span class="number">1</span>] + dp[n[<span class="number">2</span>]][n[<span class="number">3</span>]][n[<span class="number">4</span>]][<span class="number">2</span>] + dp[n[<span class="number">2</span>]][n[<span class="number">3</span>]][n[<span class="number">4</span>]][<span class="number">3</span>]) % mod;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><h5 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h5><p>$N$个二元组$(a_i,b_i)$，定义$c_1=a_1+b_1,c_i=b_i+\max⁡(c_{i−1},\sum\limits_{j=1}^{i}{a_j})$。现在你可以随意重排这$N$个二元组，求$c_N$的最小值。</p><p>zhx: 这题一看就贪心</p><p>万能贪心思路：考虑相邻的两个东西按照什么顺序来放</p><p>显然可以发现，$c_i$不严格单调递增</p><p>将$c_i$中的$b_i$放到$\max$里，那么$c_i=\max{(b_i+c_{i−1},b_i+\sum\limits_{j=1}^{i}{a_j})}$</p><p>我们令某一个$i$为$x$，$i+1$为$y$</p><p>那么较靠后的$c$值为，</p><script type="math/tex;mode=display">\begin{align*}
c_y&=\max{(b_y+c_{x},b_y+\sum\limits_{j=1}^{y}{a_j})}\\
&=\max{(b_y+b_x+\max{(c_{x-1}, \sum\limits_{j=1}^{x}{a_j})},b_y+\sum\limits_{j=1}^{y}{a_j})}
\end{align*}</script><p>令$A=c_{x-1},B=\sum\limits_{j=1}^{x-1}{a_j}$，将里面的$\max$拆开</p><p>那么，</p><script type="math/tex;mode=display">\begin{align*}
c_y=\max{ \{b_x+b_y+A,a_x+b_x+b_y+B,a_x+a_y+b_y+B\} }
\end{align*}</script><p>如果不交换，那么$c_y$就是上面式子</p><p>如果交换，</p><script type="math/tex;mode=display">\begin{align*}
c_y=\max{ \{b_x+b_y+A,a_y+b_x+b_y+B,a_x+a_y+b_x+B\} }
\end{align*}</script><p>要满足后面最小，所以<code>cmp</code>的比较判断就是$\max{ \{b_x+b_y+A,a_x+b_x+b_y+B,a_x+a_y+b_y+B\} }&lt;\max{ \{b_x+b_y+A,a_y+b_x+b_y+B,a_x+a_y+b_x+B\} }$</p><p>紧接着可以进行化简</p><p>由于小于号两边式子里都有$b_x+b_y+A$，对答案没有影响，可以删去，式子变成$\max{ \{a_x+b_x+b_y+B,a_x+a_y+b_y+B\} }&lt;\max{ \{a_y+b_x+b_y+B,a_x+a_y+b_x+B\} }$</p><p>然后删去$B$，式子变成$\max{ \{a_x+b_x+b_y,a_x+a_y+b_y\} }&lt;\max{ \{a_y+b_x+b_y,a_x+a_y+b_x\} }$</p><p>将$\max$里面相同的项提出来，式子变成$\max{ \{b_x,a_y\}+a_x+b_y}&lt;\max{ \{b_y,a_x\}+a_y+b_x}$</p><p>移项，得$a_x+b_y-\max{ \{a_x,b_y\} }&lt;a_y+b_x-\max{ \{a_y,b_x\} }$</p><p>两个数的和减去两个数中最大的，就是两个数中最小的</p><p>所以式子变成$\min{(a_x, b_y)}&lt;min(a_y,b_x)$</p>]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析 作业5</title>
    <url>/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A5/</url>
    <content><![CDATA[<p>第五周作业</p><a id="more"></a><h3 id="1-O-n-log-n-的LIS算法"><a href="#1-O-n-log-n-的LIS算法" class="headerlink" title="1. $O(n\log{n})$的LIS算法"></a>1. $O(n\log{n})$的LIS算法</h3><p>S：令$tail[i]$表示长度为$i$的LIS的结尾的最小值</p><p>R：枚举$A[j]$，二分查找第一个满足$A[j] &gt; tail[i-1]$的位置，$tail[i]=A[j]$，找不到就把$A[j]$push_back进去</p><p>T：$j$增加</p><p>B：$tail$为空</p><p>O：$tail$的长度</p><p>T：$O(n) \cdot O(\log{n})_\text{(二分查找)}=O(n\log{n})$</p><h3 id="2-Range-Partial-Sum-Query中需要使用到寻找区间-l-r-跨过的中线，给出一个-O-1-找到这个中线的方法"><a href="#2-Range-Partial-Sum-Query中需要使用到寻找区间-l-r-跨过的中线，给出一个-O-1-找到这个中线的方法" class="headerlink" title="2. Range Partial Sum Query中需要使用到寻找区间$[l,r]$跨过的中线，给出一个$O(1)$找到这个中线的方法"></a>2. Range Partial Sum Query中需要使用到寻找区间$[l,r]$跨过的中线，给出一个$O(1)$找到这个中线的方法</h3><p>$mid=l+(r-l) / 2$</p><h3 id="3-pm-1-RMQ的块内块间如何-O-n-预处理，以及如何-O-1-回答"><a href="#3-pm-1-RMQ的块内块间如何-O-n-预处理，以及如何-O-1-回答" class="headerlink" title="3. $\pm 1$RMQ的块内块间如何$O(n)$预处理，以及如何$O(1)$回答"></a>3. $\pm 1$RMQ的块内块间如何$O(n)$预处理，以及如何$O(1)$回答</h3><p>块间：使用<a href="https://oi-wiki.org/ds/sparse-table/" target="_blank" rel="noopener">ST表</a>进行预处理，时间复杂度$O(\frac{N}{L}\log{\frac{N}{L}})&lt;O(\frac{2N}{\log{N}}\log{N})=O(N)$</p><p>块内：使用ST表进行预处理，时间复杂度$O(2^L\cdot L\log{L})=O(\sqrt{N}\log{N}\log{\log{N}})$；或暴力预处理$O(2^L\cdot L^3)=O(\sqrt{N}\left(\log^{N}\right)^3)$，当大约$N&gt;10^6$时小于$O(N)$</p><p>回答询问：例如求$[l,r]$间的最小值，$a,b$是$l$后面最近的块起点和$r$前面最近的块终点，那就是$\min\left\{ RMQ_{块内}[l, a),RMQ_{块间}[a, b], RMQ_{块内}(a, r]) \right\}$，由于预处理过了所以回答是$O(1)$的。</p><h3 id="4-画出课上提到Bowling问题状态转移对应的DAG"><a href="#4-画出课上提到Bowling问题状态转移对应的DAG" class="headerlink" title="4. 画出课上提到Bowling问题状态转移对应的DAG"></a>4. 画出课上提到Bowling问题状态转移对应的DAG</h3><p><img data-src="/images/algo5_1.png" alt="DAG"></p><h3 id="5-O-n-求树的直径，边权可能为负"><a href="#5-O-n-求树的直径，边权可能为负" class="headerlink" title="5. $O(n)$求树的直径，边权可能为负"></a>5. $O(n)$求树的直径，边权可能为负</h3><p>S：令$dis[u]$表示从$u$点向它的子树出发能到达的最长距离</p><p>R：先更新$maxd = \max{\{maxd, dis[u] + dis[v] + E(u, v).w\}}$（从节点$u$出发的两条不同路径）<br>　　 再更新$dis[u]=\max{\{dis[u], dis[v] + E(u, v).w\}}$</p><p>T：DFS遍历</p><p>B：$dis[]=0$</p><p>O：$maxd$</p><p>T：$O(n)$</p><h3 id="6-O-n-3-解决环形石子合并问题"><a href="#6-O-n-3-解决环形石子合并问题" class="headerlink" title="6. $O(n^3)$解决环形石子合并问题"></a>6. $O(n^3)$解决环形石子合并问题</h3><p>$N$个环形石子合并可以拆成$2N$个横排石子合并。</p><p>S：令$v[len][i][j]$代表区间长度$len$、从$i$合并到$j$的代价</p><p>R：$v[i][i+len-1] = \min\limits_{i\leq k\leq i+len-1}{\left\{ v[i][k] + v[k+1][i+len-1]+\sum\limits_{x=i}^{j}{a[x]} \right\}}$（可用前缀和优化）</p><p>T：$len:2\rightarrow n, i:1\rightarrow 2n-len+1, $</p><p>B：$v[i][i]=a[i]$，其余为$+\infty$</p><p>O：$v[1][n]$</p><p>T：$O(n^3)$</p>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
</search>
